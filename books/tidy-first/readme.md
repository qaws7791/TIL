# Tidy First

# ⅰ. Tidyings

## Guard Clauses

- ➡️ 가드 절을 만든 후 추가적으로 조건을 헬퍼 함수나 변수로 추출할 수 있다

```javascript
if(condition) {
	if(!condition2) {
		...
	}
}
```

```javascript
if(!condition) return
if(condition2) return
...
```

얼리 리턴이 항상 좋은 것은 아니다. 

```javascript
if(condition) {
	...
}
```



## Dead Code

- 실행되지 않는 코드를 삭제
- 버전 관리 시스템을 사용한다면 언제든 나중에 되돌릴 수 있다
- ➡️ 죽은 코드를 제거한 후에는 코드를 정한 순서에 따라 재정렬할 수 있다

## Normalize Symmetries

- 코드 작성 시 일관된 패턴을 사용하여 혼란을 줄이세요. (eslint 규칙을 통한 강제)
- ➡️ 병렬 코드를 읽기 순서대로 그룹화

## New Interface, Old Implementation

- 기존 인터페이스가 코드를 어렵고 복잡하게 만든다면 기존 인터페이스를 통해 새로운 인터페이스를 만들 수 있습니다
- 중간(pass-through) 인터페이스 역할을 하는 이 인터페이스는 바꾸고 싶은대로 쉽게 변경할 수 있습니다

## Reading Order

- 읽을 때 읽는 독자를 고려해서 순서를 재정렬
- 선언 순서가 민감한 언어일 경우 독자에게 중요한 부분만 순서를 변경
- 여러 경험을 통해 적절히 판단해야 한다

## Cohesion Order

- 코드를 변경해야 할 때 변경해야 할 부분이 여러 곳에 흩어져 있다면 어려움이 있습니다
- 변경되는 요소끼리 가까이 위치하도록 코드를 재정렬할 수 있습니

## Move Declaration And Initialization Together

- 변수의 선언부는 변수에 대한 설명을 제공합니다
- 변수의 선언과 할당 부분이 서로 멀어지면 코드를 이해하기 어렵게 만들 수 있습니다
- 변수의 종속성 순서를 고려하면서 최상위에 모두 선언하는 것이 좋은지, 사용하는 위치 근처가 적절한지 고민해야 합니다

## Explaining Variables

- 장황한 표현식을 변수로 추출하여 변수이름으로 설명하면 이해하기 더 쉽다
- 정리 커밋과 동작 커밋을 분리

## Explaining Constants

- 여러 곳에서 이해되어야 하는 공통적인 값을 상수로 추출하여 한 곳에 모으고 관리
- 여러 의미 혹은 모호한 의미를 가지는 상수 표현(`ONE`)을 피하기

## Explicit Parameters

- 매개변수를 명시적으로 사용하도록 하세요
- ex. 함수에서 매개변수 전체를 받아서 일부만 사용하기 -> 사용할 매개변수만 명시적으로 입력받는 함수 만들기

## Chunk Statements

- 코드에서 맥락이 다른 부분을 빈 줄로 구분하세요
- ex. 이것은 글쓰기나 시에서 단락을 구분하는 것과 유사

## Extract Helper

- 명확한 목적을 가지고 나머지와 상호작용을 하지 않는다면 이를 헬퍼 함수로 추출하여 사용할 수 있습니다
- 코드 간의 결합을 위해 사용할 수도 있습니다(함께 실행되어야 하는 경우, 순서대로 실행되어야 하는 경우 등)

## One Pile

- "코드에서 가장 큰 비용은 작성하는 비용이 아닌 읽고 이해하는 비용이다"
- 작은 코드 조각으로 나누는 것이 때로는 이해를 방해하기도 한다
- 코드를 하나의 더미로 합친 후 다시 분해하는 과정을 통해 명확함을 되찾을 수 있다

## Explaining Comments

- 주석은 코드에서 모호한 부분을 설명하기 위한 것이다
- 코드를 읽는 독자(동료 프로그래머, 혹은 누구나)를 고려하여 코드를 이해하기 위한 추가적인 맥락(배경지식)을 제시

## Delete Redundant Comments

- 주석은 단지 문자열에 불과하기 때문에 시스템이 변경됨에 따라  관리하기 어렵고, 쓸모가 없어질 수 있다
- 코드의 동작을 단순히 설명하는 것과 같은 중복되는 주석을 제거하세요

# ⅱ. Managing

## Separate Tidying

- 정리 PR과 작업 PR을 분리하면 변경사항을 되돌릴 때 뿐만 아니라 제 3자가 검토하기 더 수월해 집니다.
- 작업 PR -> 정리 PR -> 정리 PR -> 작업 PR -> 작업 PR -> 정리 PR -> ...

## Chaining

- 정리를 시작하면 연쇄적으로 다른 정리 작업을 이어서 수행하고 싶어질 수 있습니다
- 스스로 여러 정리를 단계별로 수행하면서 실험해보는 것이 좋습니다
- 상황에 따라 너무 이른 정리는 오히려 안좋을 수 있습니다

## Batch Sizes

- 배치당 정리 작업이 많을 수록 비용이 증가합니다
  - 코드 통합을 위한 지연 시간이 길어진다. 
  - 코드가 충돌할 가능성이 높아진다
  - 코드 충돌은 코드 병합 비용 상승으로 이어진다
- 코드를 검토하고 배포하는 비용이 크기 때문에 자주 검토하는 것도 어렵습니다
- 강력한 신뢰와  문화를 갖춘 팀에서는 정리 작업에 대해 검토가 필요하지 않습니다.
- 정리 비용 낮추기 -> 정리를 늘리기, 행동 변경 비용 줄이기 -> 검토 비용이 감소

## Rhythm

- 처음에는 많을 것들을 정리하겠지만, 조금의 시간이 지나고 나면 대부분의 변경 사항이 정리된 코드 영역에서 발생합니다. 

## Getting Untangled

코드 동작 변경에 대한 3가지 시나리오

- 정리 없이 코드를 그대로 업로드: 검토하기 어려움. 잠재적인 오류 발생 가능성
- 정리 작업과 변경 작업을 분리하여 커밋: 조금 더 나은 방법이지만, 많은 작업 요구
- 작업을 되돌리고 먼저 정리하기:  더 많은 작업을 요구하지만, 일관된 커밋을 남길 수 있다

- 재구현은 처음부터 다시 코드를 작성하면서 새로운 것을 깨달을 수 있는 잠재적 가능성이 있다

## First, After, Later, Never

- Never: 코드의 동작을 변경하지 않을 것이라면 **정리를 전혀 하지 않아도** 되나요? 
  - 코드에서 동작을 변경할 필요가 전혀 없는 경우는 거의 없습니다
- Later: **나중에 정리하는 것**이 더 가치있는 경우도 있습니다
  - 당장 정리해도 좋을 게 없는 많은 정리 작업이 쌓인 경우 나중에 정리하고 싶을 수 있습니다
  - 코드 정리를 통해 뭔가를 배우거나 보상을 받을 수 있습니다
  - 원할 때 조금씩 정리할 수 있습니다
  - "정리는 시스템 동작에 대한 향후 변경을 더 쉽게 만듭니다"
- After: **정리를 먼저 한 이후에** 행동을 바꾸는 것이 나을 수 있습니다
  - 같은 영역을 곧 다시 변경해야 하는 경우
  - 지금 정리하는 것이 비용이 더 저렴한 경우
  - 정리하는 비용은 행동을 변경하는 비용과 거의 비례합니다
- First: 정리가 먼저인가?
  - 정리를 한다고 해서 변경이 더 쉬워지지 않는다면 먼저 정리하지 않아도 된다
  - 코드 변경 전 정리를 통해 코드를 더 빠르게 이해할 수 있다면 먼저 하세요
  - 코드가 단 한 번만 변경될 예정이라면 정리를 제한하세요. 시간을 들여 정리하는 것이 비효율적일 수 있습니다
  - ''정리가 필요하다''고 추측하지 말고 코드에 근거하여 분석하고 정리가 필요한 이유를 찾으세요



# ⅲTheory



## Beneficially Relating Elements

- Elements:  tokens -> expressions -> statements -> functions -> objects / modules -> systems
  - 요소들은 경계를 가지고 있습니다
  - 요소들은 하위 요소를 포함하고 있습니다
- Relating
  - Invokes(호출하다)
  - Publishes(게시하다)
  - Listens(듣다)
  - Refers(참조하다)
- Beneficially
  - 요소들은 관계 속에서 서로 이익을 줄 수 있다
  - ex. 함수가 다른 함수를 호출하여 동작을 간단하게 만들거나 다른 변수를 참조하여 값을 재사용할 수 있다
- 디자인은 요소 간의 관계로부터 얻을 수 있는 이점에 대한 것이다
- 디자이너는 이러한 요소와 관계를 관리하는 역할이다

## Structure And Behavior

## Economics: Time Value And Optionality

## A Dollar Today > A Dollar Tomorrow

## Options

## Options Versus Cash Flows

## Reversible Structure Changes

## Coupling

## Constantine’s Equivalence

## Coupling Versus Decoupling

## Cohesion

## Conclusion