[TOC]

# 1.소프트웨어 생명주기

- 소프트웨어를 개발하기 위한 설계, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것

## 폭포수 모형(Waterfall Model)

- 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계 진행
- 가장 오래되고 가장 폭넓게 사용
- 고전적 생명 주기 모형

## 프로토타입 모형(Prototype Model, 원형 모형)

- 견본품을 만들어 최종 결과물을 예층
- 사용자와 시스템 사이 인터페이스 중점

## 나선형 모형(Spiral Model, 점진적 모형)

- 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 개발
- 요구사항 첨가 가능, 유지보수 과정 필요x
- 반복 과정 : 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가 

## 애자일 모형(Agile Model)

- 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복 개발
- 고객과의 소통 중점
- 폭포수 모형과 대조적
- 종류, 스크럼, XP, 칸반, Lean, 기능중심개발(FDD)
- 핵심가치: 개인과 상호작용, 실행되는 SW, 고객과의 협업, 변화에 반응하는 것에 가치

## 소프트웨어 공학(SE)

- 소프트웨어 위기를 극복하기 위한 방안

# 2. 스크럼(Scrum) 기법

- 팀이 중심이 되어 개발 효율성을 높이는 기법
- 스크럼 팀
  - 제품 책임자: 요구사항이 담긴 백로그 작성
  - 스크럼 마스터: 가이드 역할
  - 개발팀: 제품 개발 수행
- 개발 프로세스
  1. 스프린트 계획 회의: 단기 일정 수립
  2. 스프린트: 실제 개발 작업 진행
  3. 일일 스크럼 회의: 남은 작업 시간 소멸 차트에 표시
  4. 스프린트 검토 회의
  5. 스프린트 회고

# 3.XP(eXtreme Programming) 기법

- 고객의 참여와 개발 과정 반복을 극대화
- 릴리즈 기간을 짧게 반복
- 핵심 가치: 의사소통, 단순성, 용기, 존중 , 피드백
- 개발 프로세스
  1. 릴리즈 계획 수립
  2. 이터레이션
  3. 승인 검사
  4. 소규모 릴리즈
- 주요 실천 방법
  - Pair Programming: 함께 프로그래밍
  - Collective Ownership: 코드 공동 소유
  - Test Driven Development: 테스트 케이스 먼저 작성
  - Whole Team: 각자 자신의 역할이 있고 그역할에 대한 책임
  - Continuous integration: 지속적 통합
  - Refactoring: 기능 변경없이 시스템 재구성
  - Small Releases: 릴리즈 기간 짧게 반복

# 4. 현행 시스템 파악

## 1단계

- 시스템 구성 파악
- 시스템 기능 파악
- 시스템 인터페이스 파악

## 2단계

- 아키텍처 구성 파악
- 소프트웨어 구성 파악

## 3단계

- 하드웨어 구성 파악
- 네트워크 구성 파악

# 5.개발 기술 환경 파악

## 운영체제(OS)

- 컴퓨터 시스템 자원 효율적 관리
- 컴퓨터를 편리하고 효율적 사용을 위해 환경 제공
- 요구사항 고려사항: 가용성, 성능, 기술 지원, 주변 기기, 구축 비용

## 데이터베이스 관리 시스템(DBMS)

- 사용자와 데이터베이스 사이에서 요구에 따라 정보를 생성하고 데이터베이스 관리
- 기존 파일 시스템의 데이터 종속성과 중복성 문제 해결

## 웹 애플리케이션 서버(WAS)

- 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어

## 오픈 소스(Open Souce)

- 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어

# 6.요구사항 정의

- 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과
  정삭적으로 운영되는데 필요한 제약조건

## 기능 요구사항

- 기능이나 수행과 관련

## 비기능 요구사항

- 품질이나 제약사항과 관련된 요구사항

## 사용자 요구사항

- 사용자 관점에서 본 시스템이 제공해야 할 요구사항

## 시스템 요구사항

- 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항

# 요구사항 개발 프로세스

- 개발 대상에 대한 요구사항을 체계적으로 **도출**하고 **분석**한 후 **명세**서에 정리하여
  **확인** 및 검증하는 활동

## 요구사항 도출

- 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할 것인지 식별하고 이해
- 주요 기법
  - 청취와 인터뷰
  - 설문
  - 브레인스토밍
  - 워크샵
  - 프로토타이핑
  - 유스케이스

## 요구사항 분석

- 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
- 대표적인 도구: 자료 흐름도, 자료 사전

## 요구사항 명세

- 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것

## 요구사항 확인

- 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토

## 요구공학

- 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구

## 요구사항 명세 기법

- **정형 명세 기법**
  - 수학적 원리 기반, 모델 기반, 수학적 기호, 정형화된 표기법
- 비정형 명세 기법
  - 상태/기능/객체 중심, 자연어 기반으로 서술 또는 다이어그램 작성

# 8.요구사항 분석

- 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화

## 구조적 분석 기법

- 자료의 흐름과 처리를 중심
- 하향식 방법
- 주요 분석 기법 도구
  - 자료 흐름도
  - 자료 사전
  - 소단위 명세서
  - 개체 관계도
  - 상태 전이도
  - 제어 명세서

## 자료 흐름도(DFD)

- 프로세스 : 원/네모
- 자료 흐름: 화살표
- 자료 저장소: 위 아래 테두리
- 단말: 박스

## 자료 사전(DD)

- 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록
- =: 자료 정의
- +: 자료 연결
- ( ): 자료 생략
- [ ]: 자료 선택
- { }: 자료 반복
- *　*: 자료 설명

# 9.요구사항 분석 CASE,HIPO

- 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구
- SADT: 블록 다이어그램 채택
- SREM: 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술
- PSL/PSA: 미시간 대학 개발
- TAGS: 시스템 공학 방법 응용에 대한 자동 접근 방법

## HIPO(Hierarchy Input Precess Output)

- 시스템 실행 과정인 입력,처리,출력 기능을 표현
- HIPO Chart 종류
  - 가시적 도표(도식 목차)
  - 총체적 도표(총괄 도표)
  - 세부적 도표(상세 도표)

# 10.UML(Unified Modeling Language)

- 대표적인 **객체지향 모델링 언어**
- 구성 요소: 사물, 관계, 다이어그램

## UML - 사물(Things)

- 다이어그램 안에서 관계가 형성될 수 있는 대상들
- 구조 사물: 시스템 개념적, 물리적 요소 표현
- 행동 사물: 시간과 공간에 따른 요소들의 행위 표현
- 그룹 사물: 요소들을 그룹으로 묶어서 표현
- 주해 사물: 부가적인 설명이나 제약조건 표현

## UML - 관계(Relationships)

- 사물과 사물 사이의 연관성을 표현

### 연관(Association) 관계

- 2개 이상의 사물이 서로 관련되어 있는 관계
- 화살표로 표현
- n: n개의 객체가 연관
- n..m: 최소 n개에서 최대 m개

### 집합(Aggregation) 관계

- 하나의 사물이 다른 사물에 포함되는 있는 관계
- 속이 빈 마름모로 표현

### 포함(Composition) 관계

- 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
- 속이 꽉 찬 마름모로 표현

### 일반화(Generalization) 관계

- 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계
- 속이 빈 화살표로 표현

### 의존(Dependency) 관계

- 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
- 소유 관계는 아니지만 영향을 미치는 관계
- 점선 화살표로 표현

### 실체화(Realization) 관계

- 사물이 할 수 있거나 해야 하는 기능으로, 서로를 그룹화할 수 있는 관계
- 속이 빈 점선 화살표로 표현

## UML- 다이어그램(Diagram)

- 사물과 관계를 도형을 표현
- 정적 모델링 -> 구조적 다이어그램
- 동적 모델링 -> 행위  다이어그램

### 구조적(structural) 다이어그램

- Class Diagram: 클래스 사이 관계
- Object Diagram: 객체 사이 관계. 럼바우 기법에서 객체 모델링에 사용
- Component Diagram: 컴포넌트 사이 관계. 구현 단계에서 사용
- Deployment Diagram: 물리적 요소들의 위치 표현. 구현 단계에서 사용
- Composite Structure Diagram: 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 표현
- Package Diagram: 모델 요소들을 그룹화한 패키지들의 관계 표현

### 행위(Behavioral) 다이어그램

- Use Case Diagram: 사용자 요구 분석
- Sequence Diagram: 시스템이나 객체들이 주고 받는 메시지 표현
- Communication Diagram: 메시지와 객체들 간의 연관 관계 표현
- State Diagram: 상태가 어떻게 변화하는지 표현. 럼바우 기법에서 동적 모델링에 사용
- Activity Diagram: 처리 흐름을 순서에 따라 표현
- Interaction Overview Diagram: 상호작용 다이어그램 간의 제어 흐름 표현
- Timing Diagram: 객체 상태 변화와 시간 제약을 명시적으로 표현

### 스테레오 타입(Stereo type)

- UML에서 기본 기능 외에 추가적인 기능 표현
- <<>> 길러멧으로 표현
- <<include>>: 포함 관계
- <<extends>>: 확장 관계
- <<interface>>: 인터페이스를 정의하는 경우
- <<exception>>: 예외를 정의하는 경우
- <<constructor>>: 생성자 역할을 수행하는 경우

# 13. 유스케이스 다이어그램

## 기능 모델링

- 개발될 시스템이 갖춰야 할 기능을 정리한 후 사용자와 함께 정리된 내용을 공유하기 위해 그림으로 표현
- 기능 모델링 종류
  - Use Case 다이어그램: 수행할 수 있는 기능을 사용자 관점에서 표현
  - Activity 다이어그램: 처리 흐름에 따라 순서대로 표현

# 15. 클래스 다이어그램

## 정적 모델링

- 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조 표현
- Class 다이어그램: 클래스와 클래스가 가지는 속성, 클래스 사이 관계 표현
- 연관 클래스: 연관 관계에 있는 두 클래스에 추가적인 속성이 필요한 경우 생성

# 16. 시퀀스 다이어그램

## 동적 모델링

- 시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현
- 동적 모델링 종류
- Sequence 다이어그램: 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정 그림으로 표현
- Communication 다이어그램: 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정 그림으로 표현
- State 다이어그램: 객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현

# 19. 패키지 다이어그램

- 요소들을 그룹화한 패키지간의 의존 관계 표현
- 대규모 시스템에서 주요 요소 간 종속성 파악

# 20. 소프트웨어 개발 방법론

- 소프트웨어 개발, 유지보수 등에 필요한 여러가지 일들의 수행 방법과
  각종 기법 및 도구를 체계적으로 정리하여 표준화

## 구조적 방법론

- 사용자 요구사항을 파악하여 문서화하는 처리 중심 방법론
- 개발 절차
  1. 타당성 검토
  2. 계획
  3. 요구사항
  4. 설계
  5. 구현
  6. 시험
  7. 운용/유지보수

## 정보공학 방법론

- 정형화된 기법들을 연관성 있게 통합 및 적용하는 자료(Data) 중심 방법론
- 개발 절차
  1. 정보 전략 계획
  2. 업무 영역
  3. 업무 시스템 설계
  4. 업무 시스템 구축

## 객체지향 방법론

- 객체들을 조립해서 필요한 소프트웨어 구현
- 개발 절차
  1. 요구 분석
  2. 설계
  3. 구현
  4. 테스트 및 검증
  5. 인도

## 컴포넌트 기반(CBD) 방법론

- 기존의 컴포넌트를 조합하여 새로운 애플리케이션 만드는 방법론
- 개발 절차
  - 개발 준비
  - 분석
  - 설계
  - 구현
  - 테스트
  - 전개
  - 인도

## 제품 계열 방법론

- 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발
- 영역 공학, 응용공학

# 21. SW 공학의 발전적 추세

## 소프트웨어 재사용

- 합성 중심: 블록을 만들어서 끼워 맞춰 소프트웨어 완성(블록 구성 방법)
- 생성 중심: 추상화 형태로 써진 명세를 구체화하여 프로그램 작성(패턴 구성 방법)

## 소프트웨어 재공학

- 새로운 요구에 맞춰 기존 시스템을 이용해 새로운 기능을 추가하여 소프트웨어 성능 향상

## CASE(Computer Aided Software Engineering)

- 디버깅 과정을 전용 소프트웨어로 자동화

# 22. 비용 산정 기법

## 프로젝트 요소

- 제품 복잡도
- 시스템 크기
- 요구되는 신뢰도

## 자원 요소

- 인적 자원
- 하드웨어 자원
- 소프트웨어 자원

## 생산성 요소

- 개발자 능력
- 개발 기간

## 하향식 비용 산정 기법

- 전문가 감정 기법: 경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰
- 델파이 기법: 많은 전문가의 의견을 종합하여 산정

## 상향식 비용 산정 기법

- LOC(원시 코드 라인 수) 기법: 각 기능의 원시 코드 라인 수의
  비관치, 낙관치, 기대치를 측정하여 예측치를 구하여 비용 산정
- 예측치 = (낙관치 + 4*기대치 + 비관치) / 6
- 개발 단계별 인월수 기법: 생명 주기 각 단계별 각 기능에 대한 필요한 노력을 산정

## 수학적 산정 기법

- 상향식 비용 산정 기법 중 하나

### COCOMO 소프트웨어 개발 유형

- LOC에 의한 비용 산정 기법
- 조직형(Organic): 5만 라인 이하
- 반분리형(Semi-Detached): 30만 라인 이하
- 내장형(Embedded): 30만 라인 이상

### COCOMO 모형 종류

- 기본형
- 중간형
- 발전형

### Putnam 모형

- 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상
- Rayleigh-Norden 곡선의 노력 분포도에 기초

### 기능 점수(FP) 모형

- 총 기능 점수와 영향도를 이용해 기능 점수를 구해 비용 산정

### 비용 산정 자동화 추정 도구

- SLIM, ESTIMACS

# 26. 프로젝트 일정 계획

- 프로젝트의 프로세스를 이루는 소작업을 파악하여 소작업의 순서와 일정을 정하는 것

## PERT(프로그램 평가 및 검토 기술)

- 프로젝트에 필요한 전체 작업의 상호 관계를 표시하는 네트워크

## CPM(임계 경로 기법)

- 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용
- 원형 노드(작업 이름, 소요기간), 박스 노드(이정표 이름과 예상 완료 시간)

## 간트 차트

- 프로젝트의 각 작업 시작과 종료 일정을 막대 도표를 이용해 표시
- 시간선 차트라고도 한다.

# 28. 소프트웨어 개발 표준

- 소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준

## ISO/IEC 12207

- 표준 소프트웨어 생명 주기 프로세스
- 기본/지원/조직 생명 주기 프로세스  

## CMMI

- 개발 조직의 업무 능력 및 조직 성숙도 평가 모델
- 소프트웨어 프로세스 성숙도
  - 초기 -> 관리 -> 정의 -> 정량적 관리 -> 최적화

## SPICE

- 소프트웨어 프로세스를 평가 및 개선하는 국제 표준
- 구성
  - 고객-공급자 프로세스
  - 공학 프로세스
  - 지원 프로세스
  - 관리 프로세스
  - 조직 프로세스
- 프로세스 수행 능력 단계
  - 불완전
  - 수행
  - 관리
  - 확립
  - 예측
  - 최적화

# 30. 소프트웨어 개발 프레임워크

- 스프링 프레임워크: 자바플랫폼을 위한
- 전자정부 프레임워크: 대한민국의 공공부문 정보화 산업 시 정보 시스템 구축을 지원
- 닷넷 프레임워크: Windows 프로그램 개발 실행 환경 제공
- 특성
  - 모듈화
  - 재사용성
  - 확장성
  - 제어의 역흐름

# 31. 데이터 전환

- 운영 중인 기존 정보 시스템에 축적되어 있는 데이터를 **추출(Extraction)**하여 새로 개발한 정보 시스템에
  운영할 수 있도록 **변환(Transformation)**한 후 **적재(Loading)** 하는 일련의 과정

# 32. 데이터 검증

- 원천 시스템의 데이터를 목적 시스템의 데이터로 전환하는 과정이 정상적으로 수행되었는지
  여부를 확인하는 과정
- 로그 검증
- 기본 항목 검증
- 응용 프로그램 검증
- 응용 데이터 검증
- 값 검증

# 33. 오류 데이터 측정 및 정제

1. 데이터 품질 분석
2. 오류 데이터측정
3. 오류 데이터 정제

## 오류 상태

- Open: 오류 보고만 된 상태
- Assigned: 개발자에게 오류를 전달한 상태
- Fixed: 오류를 수정한 상태
- Closed: 테스트를 다시 했을 때 오류가 발견되지 않은 상태
- Deferred: 오류 수정을 연기한 상태
- Clarified / Classified: 오류가 아니라고 확인한 상태

# 34. 데이터베이스 개요

## 데이터 저장소

- 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것

## 데이터베이스

- 공동으로 사용될 데이터를 **중복을 배제**하여 **통합**하고, 쉽게 접근하여 처리할 수 있도록 저장장치에
  저장하여 **항상 사용**할 수 있도록 운영하는 운영 데이터
- 데이터 베이스 구분
  - 통합된 데이터
  - 저장된 데이터
  - 운영 데이터
  - 공용 데이터

## DBMS(DataBase Management System)

- 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리
- 3가지 필수 기능
  - 정의 기능
  - 조작 기능
  - 제어 기능

## 데이터의 독립성

- 논리적 독립성: 응용 프로그램과 데이터베이스를 독립
- 물리적 독립성: 물리적 장치를 독립

## 스키마

- 데이터베이스의 구조와 제약조건에 관한 전반적인 명세
- 외부 스키마: 데이터베이스의 논리적 구조 정의
- 개념 스키마: 데이터베이스의 전체적인 논리적 구조
- 내부 스키마: 물리적 저장장치 입장에서 본 데이터베이스 구조

# 35. 데이터베이스 설계

## 데이터베이스 설계시 고려사항

- 무결성: 정해진 제약 조건을 항상 만족
- 일관성: 특정 질의에 대한 응답이 항상 일정
- 회복: 장애 발생시 장애 발생 이전의 상태로 복구
- 보안: 데이터의 노출, 변경, 손실로 부터 보호
- 효율성: 응답시간 단축, 시스템의 생산성, 저장 공간의 최적화
- 데이터베이스 확장: 운영에 영향을 미치지 않으면서 지속적으로 데이터를 추가

## 데이터베이스 설계 순서

1. 요구 조건 분석: 필요한 용도를 파악
2. 개념적 분석: 현실 세계 인식 -> 추상적 개념
3. 논리적 설계: 현실 세계 자료 -> 논리적 자료 구조
4. 물리적 설계: 논리적 구조 데이터 -> 물리적 구조 데이터
5. 구현: 데이터베이스 스키마를 파일로 생성

# 36. 데이터 모델의 개념

- 현실 세계의 정보들을 단순화, 추상화하여 체계적으로 표현한 개념적 모형
- 구성 요소: 개체, 속성, 관계
- 종류: 개념적/논리적/물리적 데이터 모델
- 데이터 모델 3요소 : 구조, 연산, 제약 조건

## 개념적 데이터 모델

- 현실세계에 대한 인식을 추상적 개념으로 표현

## 논리적 데이터 모델

- 개념적 구조를 컴퓨터 세계의 환경에 맞도록 변환

## 데이터 모델에 표시할 요소

- 구조: 개체 타입들 간의 관계. 데이터 구조 및 정적 성질 표현
- 연산: 데이터베이스의 실제 데이터를 처리하는 작업에 대한 명세
- 제약 조건: 데이터베이스의 실제 데이터의 논리적인 제약 조건

# 37. 데이터 모델의 구성 요소

## 개체(entity)

- 데이터베이스에 표현하려는 것
- 개념이나 정보 단위 같은 현실 세계의 대상체

## 속성(Attribute)

- 데이터베이스를 구성하는 가장 작은 논리적 단위
- Degree(차수): 속성의 수
- 속성의 특성에 따른 분류
  - 기본 속성: 업무 분석을 통해 정의한 속성
  - 설계 속성: 설계 과정에서 도출해내는 속성
  - 파생 속성: 다른 속성으로부터 영향을 받아 발생
- 속성의 개체 구성 방식에 따른 분류
  - 기본키 속성: 개체를 유일하게 식별
  - 외래키 속성: 다른 개체와의 관계에서 포함
  - 일반 속성: 개체에 포함되어 있고 기본키나 외래키가 아닌 속성

## 관계(Relationship)

- 개체와 개체 사이의 논리적인 연결
- 관계의 형태:
  - 1:1 / 1:N / N:M
- 관계의 종류
  - 종속(Dependent) 관계: 주종 관계
  - 중복(Redundant) 관계: 2번 이상의 종속 관게 발생
  - 재귀(Recursive) 관계: 자기 자신과 갖는 관계
  - 배타(Exclusive) 관계: 개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계. AND, OR

# 38. 식별자(Identifier)

- 하나의 개체 내에서 각각의 인스턴스를 유일하게 구별할 수 있는 구분자

### 대표성 여부

- 주 식별자: 개체를 대표하는 유일한 식별자
  - 유일성 / 최소성 / 불변성 / 존재성
- 보조 식별자: 주 식별자를 대신할  수 있는 식별자

### 스스로 생성 여부

- 내부 식별자: 개체 내에서 스스로 생성
- 외부 식별자: 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용

### 단일 속성 여부

- 단일 식별자: 주 식별자가 한 가지 속성으로만 구성
- 복합 식별자: 주 식별자가 두 개 이상의 속성으로 구성

### 대체 여부

- 원조 식별자: 업무에 의해 만들어지는 가공되지 않은 원래 식별자
- 대리 식별자: 주 식별자 속성이 두 개 이상인 경우 하나의 속성으로 묶어 사용

### 후보 식별자

- 개체에서 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성 집합

# 39. E-R(개체-관계) 모델

- 개체 -> 사각형
- 관계 -> 마름로
- 속성 -> 타원
- 이중 타원 -> 다중 값
- 밑줄 타원 -> 기본키 속성
- 복수 타원 -> 복합 속성
- 관계 -> 숫자 N:M
- 선 -> 개체와 속성을 연결

# 40. 관계형 데이터베이스

- 2차원적인 표를 이용해 데이터 상호 관계를 정의
- 릴레이션 -> 표
- 릴레이션 스키마 -> 구조
- 릴레이션 인스턴스 -> 실제 값들

## 튜플

- 릴레이션을 구성하는 각각의 행
- 튜플의 수 -> Cardinality(기수)

## 속성

- 가장 작은 논리적 단위
- 속성의 수 -> Degree(차수)

## 도메인(Domain)

- 하나의 속성이 취할 수 있는 같은 타입의 원자값들의 집합

## 릴레이션 특징

- 튜플은 모두 상이하다
- 순서가 없다
- 시간에 따라 변한다
- 속성들의 순서는 중요하지 않다
- 속성의 명칭은 유일
- 속성들의 부분집합을 키로 설정
- 원자값만을 저장

# 41. 관계형 데이터베이스 제약 조건 - key

## 키(Key)

- 조건에 만족하는 튜플이나 순서대로 정렬할 때 기준이 되는 속성
- 후보키: 튜플을 유일하게 식별하기 위해 사용하는 속성들의 집합
  - 유일성
  - 최소성
- 기본키: 후보키 중 특별히 선정된 키
  - 중복된 값이나 NULL 값 불가능
- 대체키: 기본키를 제외한 나머지 후보키
- 슈퍼키: 유일성을 만족하지만, 최소성을 만족하지 못하는 키
- 외래키: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성집합

# 42. 관계형 데이터베이스의 제약 조건 - 무결성

## 무결성(Integrity)

- 데이터와 실제값이 일치하는 정확성
- 무결성의 종류
  - 개체 무결성: 기본키를 구성하는 속성은 Null 값이나 중복값 불가능
  - 참조 무결성: 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함
  - 도메인 무결성: 속성 값은 정의된 도메인에 속한 값이어야 함
  - 사용자 정의 무결성: 속성 값이 제약조건에 만족되어야 함
  - NULL 무결성: 릴레이션의 특정 속성 값이 Null이 될 수 없도록 함
  - 고유 무결성: 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 함
  - 키 무결성: 하나의 릴레이션에는 적어도 하나의 키가 존재해야 함
  - 관계 무결성: 튜플의 삽입 가능 여부나 다른 릴레이션 간의 튜플들 관계에 대한 적절성 여부 지정
- 데이터 무결성 강화
  - 애플리케이션
  - 데이터베이스 트리거
  - 제약 조건

# 43. 관계대수 및 관계해석

## 관계대수

- 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를
  기술하는 절차적인 언어

## 순수 관계 연산자

### Select

- 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션 생성
- 수평 연산
- 기호 : σ

### Project

- 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션 생성
- 수직 연산
- 중복 발생시 중복 제거
- 기호: π

### Join

- 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐 새로운 릴레이션 생성
- 기호: ▷◁

### Division

- R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
- 기호: ÷

## 일반 집합 연산자

- 합집합(UNION; ∪)
- 교집합(INTERSECTION; ∩)
- 차집합(DIFFERENCE; －)
- 교차곱(CARTESIAN PRODUCT; ×)

## 관계해석

- 관계 데이터의 연산을 표현하는 방법

# 44. 이상 / 함수적 종속

## 이상(Anomaly)

- 데이터의 중복이 발생하여 테이블 조작 시 문제가 발생하는 현상
- 삽입 이상: 원하지 않은 값들로 인해 삽입할 수없는 현상
- 삭제 이상: 관련 없는 값들도 함께 삭제되는 현상
- 갱신 이상: 일부 튜플의 정보만 갱신되어 종에 불일치성이 생기는 현상

## 함수적 종속

- 속성 X의 값 각각에 대해 시간에 상관없이 항상 속성 Y의 값이 오직 하나만 연관 됨.

# 45. 정규화

- 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정
- 1NF: **도**메인이 원자값
- 2NF: 부분적 함수 종속 제거
- 3NF: **이**행적 함수 종속 제거
- BCNF: 결정자이면서 후보키가 아닌 것 제거
- 4NF: **다**치 종속 제거
- 5NF: **조**인 종속성 이용

# 46. 반정규화

- 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행휘

## 테이블 통합

- 두 개의 테이블이 조인되어 사용되는 경우가 많을 경우 성능 향상을 위해 통합
- 1:1 / 1:N / 슈퍼타입&서브타입 

## 테이블 분할

- 수평 분할 - 레코드 기준 분할
- 수직 분할 - 속성 기준 분할

## 중복 테이블 추가

- 여러 테이블에서 데이터를 추출해 사용 시
- 다른 서버에 저장된 테이블을 이용 시

## 중복 속성 추가

- 데이터를 조회하는 경로 단축을 위해 자주 사용하는 속성을 하나 더 추가
- 조인 자주 발생 시
- 접근 경로 복잡 시
- 액세스 조건으로 자주 사용될 경우
- 기본키 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우

# 47. 시스템 카탈로그

- 시스템의 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스

## 메타 데이터

- 시스템 카탈로그에 저장된 정보

## 데이터 디렉터리

- 데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템

# 48. 데이터베이스 저장 공간 설계

- 테이블: 데이터베이스 가장 기본적인 개체
- 컬럼: 테이블의 열을 구성하는 요소
- 테이블스페이스: 테이블이 저장되는 논리적인 영역

## 테이블의 종류

- 일반 테이블
- 클러스터드 인덱스 테이블: 기본키나 인덱스키의 순서에 따라 데이터가 저장
- 파티셔닝 테이블: 파티션으로 나눈 테이블
- 외부 테이블: 일반 테이블처럼 이용할 수 있는 외부 파일
- 임시 테이블: 트랜잭션이나 세션별로 데이터를 저장하고 처리

# 49. 트랜잭션 분석 / CRUD 분석

- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 
  작업의 단위 또는 일련의 연산

## 트랜잭션의 특성

- **Atomicity(원자성)**: 모두 반영되도록 완료하거나 전혀 반영되지 않도록 복구
- **Consistency(일관성)**: 언제나 일관성 있는 데이터베이스 상태
- **Isolation(독립성)**: 하나의 트랜잭션 실행 중 다른 트랜잭션 연산이 끼어들 수 없음
- **Durability(영속성)**: 시스템이 고장나더라도 영구적으로 반영

# 50. 인덱스

- 데이터 레코드를 빠르게 접근하기 위해 <키 값,포인터> 쌍으로 구성되는 데이터 구조

## 인덱스 종류

- 트리 기반 인덱스: 트리 구조
- 비트맵 인덱스: 인덱스 컬럼의 데이터를 Bit 값으로 변환하여 인덱스 키로 사용
- 함수 기반 인덱스: 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용
- 비트맵 조인 인덱스: 다수의 조인된 객체로 구성
- 도메인 인덱스: 개발자가 필요한 인덱스를 직접 만들어 사용
- 클러스터드 인덱스: 인덱스 키의 순서에 따라 데이터가 정렬
- 넌클러스터드 인덱스: 인덱스 키 값만 정렬, 실제 데이터는 정렬 X

# 51. 뷰 / 클러스터

## 뷰(View)

- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된,
  이름을 가지는 가상 테이블
- 장점
  - 논리적 데이터 독립성
  - 동일 데이터에 대해 동시에 여러 사용자의 상이한 요구 지원
  - 사용자의 데이터 관리 간편화
  - 접근 제어를 통한 자동 보안 제공
- 단점
  - 독립적인 인덱스 X
  - 뷰의 정의 변경 불가
  - 삽입, 삭제, 갱신 연산 제약

## 클러스터(Cluster)

- 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장방법
- 처리 범위가 넓은 경우 -> 단일 테이블 클러스터링
- 조인이 많이 발생하는 경우 -> 다중 테이블 클러스터링

# 52. 파티션

- 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것
- 장점
  - 데이터 접근 시 액세스 범위 감소로 쿼리 성능 향상
  - 파티션별 데이터 분산 저장으로 디스크 성능 향상
  - 파티션별 백업 및 복구 수행으로 빠른 속도
  - 시스템 장애시 데이터 손상 최소화
  - 데이터 가용성 향상
  - 파티션 단위로 입출력 분산
- 단점
  - 테이블 간 조인에 대한 비용 증가
  - 용량이 작은 테이블 파티셔닝 시 오히려 성능 저하
- 종류
  - 범위 분할: 지정한 열의 값을 기준을 분류
  - 해시 분할: 해시 함수를 적용한 결과 값에 따라 데이터를 분할
  - 조합 분할: 범위 분할한 다음 해시 함수 적용

# 53. 분산 데이터베이스 설계

- 분산 데이터 베이스 설계
- 위치 투명성: 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스
- 중복 투명성: 동일 데이터가 여러 곳에 중복되어 존재해도 사용자는 하나의 데이터만 존재하는 것처럼 사용
- 병행 투명성: 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다
- 장애 투명성: 장애에도 불구하고 트랜잭션을 정확하게 처리

# 54. 데이터베이스 이중화 / 서버 클러스터링

## 데이터베이스 이중화

- 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리
- Eager 기법: 트랜잭션 수행 중 데이터 변경 발생 시 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용
- Lazy 기법: 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달

## 데이터베이스 이중화 구성 방법

- 활동-대기: 활성 DB에 장애가 발생 시 대기 상태에 있던 DB가 자동으로 모든 서비스 대신 수행
- 활동-활동: 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한 쪽 DB에 문제 발생 시 다른 DB가 수행

## 클러스터링

- 두 대 이상의 서버를 하나의 서버처럼 운영
- 고가용성 클러스터링: 하나의 서버에 장애 발생 시 다른 서버가 받아 처리
- 병렬 처리 클러스터링: 하나의 작업을 여러 개의 서버에서 분산 처리

# 55. 데이터베이스 보안

- 권한이 없는 사용자가 액세스하는 것을 금지
- 암호화: 평문을 암호문으로 변환
  - 개인키 암호 방식
  - 공개키 암호 방식

## 접근통제

- 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것
- 접근통제 3요소
  - 접근통제 정책: 어떤 주체가 언제 어디서 어떤 객체에게 어떤 행위에 대한 허용 여부를 정의하는 것
  - 접근통제 메커니즘: 정의된 접근통제 정책을 구현하는 기술적인 방법
  - 접근통제 보안모델: 보안 정책을 구현하기 위한 정형화된 모델

### 접근통제 기술

- **임의 접근통제(DAC)**: 사용자의 **신원**에 따라 접근 권한 부여
- **강제 접근통제(MAC)**: 주체와 객체의 등급을 비교하여 접근 권한을 부여
- **역할기반 접근통제(RBAC)**: 사용자의 **역할**에 따라 접근 권한 부여

### 접근통제 정책

- 신분 기반 정책: 주체나 그룹의 신분에 근거하여 객체의 접근을 제한
  - IBP(Individual-Based Policy): 최소 권한  정책. 단일 주체에게 하나의 객체에 대한 허가 부여
  - GBP(Group-Based Policy): 복수 주체에 하나의 객체에 대한 허가 부여
- 규칙 기반 정책: 주체가 갖는 권한에 근거하여 객체의 접근을 제한
  - MLP(Multi-Level Policy): 사용자나 객체별로 지정된 기밀 분류에 따른 정책
  - CBP(Compartment-Based Policy): 집단별로 지정된 기밀 허가에 따른 정책
- 역할 기반 정책: 주체가 맡은 역할에 근거하여 객체의 접근을 제한

### 접근통제 보안 모델

- 기밀성 모델 - 군사적 목적, 최초의 수학적 모델, 기밀 보장 최우선
- 무결성 모델 - 무결성 기반
- 접근통제 모델 - 대표적으로 접근통제 행렬

### 접근통제 조건

- 값 종속 통제: 객체에 저장된 값에 따라 다르게 접근통제를 허용
- 다중 사용자 통제: 다수의 사용자가 동시에 접근을 요구하는 경우 사용
- 컨텍스트 기반 통제: 특정 시간, 네트워크 주소, 접근 경로, 인증 수준 등에 근거하여 접근 제어

# 56. 데이터베이스 백업

- 로그 파일: 데이터베이스 상태 변화를 시간의 흐름에 따라 모두 기록
- 백업 종류
  - 물리 백업
  - 논리 백업

## 데이터베이스 복수 알고리즘

- NO-UNDO: 트랜잭션 완료 전에는 변경 내용이 데이터베이스에 기록되지 않음.
- NO-REDO: 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장 매체에 기록했으므로 트랜잭션 내용을 다시 실행할 필요가 없음

# 57. 스토리지

- 대용량 데이터 저장을 위해 서버와 저장장치를 연결
- DAS(Direct Attached Storage): 전용 케이블로 직접 연결
- NAS(Network Attached Storage): 서버와 저장장치를 네트워를 통해 연결
- SAN(Storage Area Network): 전용 네트워크를 별도로 구성

# 58. 논리 데이터 모델의 변환

- 엔티티를 테이블로 변환
  - 엔티티 -> 테이블
  - 속성 -> 컬럼
  - 주 식별자 -> 기본키
  - 외부 식별자 -> 외래키
  - 관계 -> 관계
- 슈퍼타입/서브타입을 테이블로 변환
  - 슈퍼타입 기준: 서브타입을 슈퍼타입에 통합
  - 서브타입 기준: 슈퍼타입 속성들을 각각의 서브타입에 추가
  - 개별타입 기준: 슈퍼타입과 서브타입들을 각각을 개별적인 테이블로
- 속성을 컬럼으로 변환
  - 일반 속성 변환
  - Primary UID를 기본키로 변환
  - Primary UID를 기본키로 변환
  - Secondary UID를 유니크키로 변환
- 관계를 외래키로 변환

# 59. 물리 데이터 모델 품질 검토

## 품질 기준

- 정확성
- 완전성
- 준거성
- 최신성
- 일관성
- 활용성

# 60. 자료구조

## 선형 구조

- 배열(Array): 동일한 크기와 형
- 선형 리스트(Linear List)
  - 연속 리스트(Contiguous List): 연속되는 기억장소에 저장
  - 연결 리스트(Linked List): 노드 포인터를 통한 서로 연결
- 스택(Stack): 한쪽으로만 삽입,삭제가 되는 후입선출
- 큐(Queue): 리스트 한쪽에서는 삽입, 다른 한쪽은 삭제가 되는 선입선출
- 데크(Deque): 양쪽에서 삽입,삭제가 가능

## 비선형 구조

- 트리(Tree): 사이클이 없는 그래프
- 그래프(Graph): 노드와 간선을 이용

# 61. 트리(Tree)

- 노드: 기본 요소
- 근 노드: 트리의 맨 위 노드
- 단말 노드: 자식이 없는 노드(Degree=0)
- 비단말 노드: 자식이 있는 노드(Degree>0)
- 조상 노드: 임의의 노드에서 근 노드까지의 경로
- 자식 노드: 노드에 연결된 다음 레벨 노드들
- 부모 노드: 노드에 연결된 이전 레벨 노드들
- 형제 노드: 동일한 부모를 갖는 노드들
- 깊이: Tree에서 최대의 레벨
- 차수(Degree): 각 노드에서 나온 가지의 수

# 62. 이진트리

- 차수가 2이하인 노드들로 구성된 트리
- 트리 운행법
  - Preorder: Root -> L -> R
  - Inorder: L -> Root -> R
  - Postorder: L -> R -> Root

# 63. 정렬

### 삽입 정렬

- 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬
- O(n^2)

### 선택 정렬

- 최소값을 찾아 첫 번째에 놓고, 다음 최소값을 찾아 두 번째에 놓고 ... 반복
- O(n^2)

### 버블 정렬

- 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치 서로 교환
- O(n^2)

### 쉘 정렬

- 각 서브 파일을 구성하고 이를 삽입 정렬로 순서 배열
- O(n^2)

### 퀵 정렬

- 키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 과정 반복
- 평균 O(nlog₂n) 최악 O(n^2)

### 힙 정렬

- 전이진 트리를 이용한 정렬방식
- O(nlog₂n)

### 2-Way 합병 정렬

- 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병
- O(nlog₂n)

### 기수 정렬

- Queue를 이용하여 자릿수별로 정렬 

# 64. 통합 구현

- 송수신 모듈과 중계 모듈 간의 연계를 구현

# 65. 연계 메커니즘

- 송신 시스템과 수신 시스템으로 구성
- 연계 방식
  - 직접 연계: 중간 매개체 없이 송수신 시스템이 직접 연계
  - 간접 연계: 송수신 시스템 사시에 중간 매개체를 두어 연계
- 구간별 오류 발생 지점
  - 송신 시스템
  - 수신 시스템
  - 연계 서버

# 67. 연계 데이터 보안

- 전송 구간 보안: 전송 구간에서 데이터를 쉽게 가로챌 수 없도록 암호화 기능이 포함된 프로토콜 사용
- 데이터 보안: 송신 시스템에서 연계 데이터를 추출하거나 
  수신 시스템에서 데이터를 운영DB에 반영할 때 데이터를 암복호화

# 68. XML(eXtensible Markup Language)

- 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어

## SOAP(Simple Object Access Protocol)

- 컴퓨터 네트워크 상에서 HTTP/HTTPS, SMTP 등을 이용하여 XML을 교환하기 위한 통신 규약

## WSDL(Web Services Description Language)

- 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어

# 70. 개발 환경 구축

- 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것

# 71. 소프트웨어 아키텍처

- 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체

## 모듈화

- 시스템의 기능들을 모듈 단위로 나누는 것

## 추상화(Abstraction)

- 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것
- 추상화 유형
  - 과정 추상화: 전반적인 흐름 파악
  - 데이터 추상화: 데이터 구조를 대표할 수 있는 표현으로 대체
  - 제어 추상화: 대표할 수 있는 표현으로 대체

## 단계적 분해(Stepwise Refinement)

- 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법

## 정보 은닉(Information Hiding)

- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

## 상위 설계와 하위 설계

- 상위 설계: 아키텍처 설계 / 시스템 전체적인 구조 / 구조, DB, 인터페이스
- 하위 설계: 모듈 설계 / 시스템 내부 구조 및 행위 / 컴포넌트, 자료구조, 알고리즘

# 72. 아키텍처 패턴

- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

## 레이터 패턴(Layers Pattern)

- 시스템을 계층으로 구분하여 구성
- OSI 참조 모델

## 클라이언트-서버 패턴(Client-Server Pattern)

- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성

## 파이프-필터 패턴(Pipe-Filter Pattern)

- 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
- UNIX의 Shell

## 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)

- 서브시스템을 모델, 뷰, 컨트롤러로 구조화
- 대화형 애플리케이션에 적합

## 마스터-슬레이브 패턴(Master-Slave Pattern)

- 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업 수행

## 브로커 패턴(Broker Pattern)

- 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가
  요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴

## 피어-투-피어 패턴(Peer-To-Peer Pattern)

- 피어라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴

## 이벤트-버스 패턴(Event-Bus Pattern)

- 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스터들이 메시지를 받아 이벤트를 처리

## 블랙보드 패턴(Blackboard Pattern)

- 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴

## 인터프리터 패턴

- 프로그램 코드의 각 라인을 수행하는 방법을 지정하고,
  기호마다 클래스를 갖도록 구성된 패턴

# 73. 객체지향

- 각 요소들을 객체로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법
- 객체지향 구성 요소
  - **객체(Object)**: 데이터와 함수를 묶어 놓은 소프트웨어 모듈
  - **클래스(Class)**: 공통된 속성과 연산을 갖는 객체의 집합
  - **메시지(Message)**: 객체들 간의 상호작용에 사용되는 수단

## 캡슐화(Encapsulation)

- 외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것

## 상속(Inheritance)

- 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

## 다형성(Polymorphism)

- 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력

## 연관성(Relationship)

- 두 개 이상의 객체들이 상호 참조하는 관계
- is member of : 연관화
- is instance of : 분류화
- is part of : 집단화
- is a : 일반화, 특수화/상세화

# 객체지향 분석 및 설계

- Object Oriented Analysis(OOA): 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링

## 객체지향 분석 방법론

- Rumbaugh(럼바우) 방법: 분석 활동을 객체/동적/기능 모델로 나누어 수행
  1. 객체 모델링: 속성과 연산 식별 및 객체들 간의 관계 규정, 객체 다이어그램 이용
  2. 동적 모델링: 상태 다이어그램 이용
  3. 기능 모델링: 자료 흐름도 이용
- Booch(부치) 방법: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용
- Jacobson 방법: 유스케이스를 강조하여 사용
- Coad와 Yourdon 방법: E-R 다이어그램을 사용하여 객체 행위 모델링
- Wirfs-Brock 방법: 분석과 설계 간의 구분이 없고 고객 명세서를 평가하여 설계 작업까지 연속 수행

## 객체지향 설계 원칙(SOLID 원칙)

- 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 원칙
- 단일 책임 원칙(SRP): 객체는 단하나의 책임만 가져야 한다
- 개방-폐쇄 원칙(OCP): 기존의 코드를 변경하지 않고 기능을 추가할 수 있어야 한다
- 리스코프 치환 원칙(LSP): 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다
- 인터페이스 분리 원칙(ISP): 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다
- 의존 역전 원칙(DIP): 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다

# 75. 모듈

- 결합도: 모듈 간의 상호 의존하는 정도
- 팬인: 어떤 모듈을 제어하는 모듈의 수
- 팬아웃: 어떤 모듈에 의해 제어되는 모듈의 수

## 결합도의 종류(강한 순서)

1. 내용 결합도: 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정
2. 공통 결합도: 공유되는 공통 데이터 영역을 여러 모듈이 사용
3. 외부 결합도: 모듈 내의 데이터를 외부 다른 모듈에서 참조
4. 제어 결합도: 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소 전달
5. 스탬프 결합도: 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달
6. 자료 결합도: 모듈 간의 인터페이스가 자료 요소로만 구성

- 응집도: 모듈의 내부 요소들이 서로 관련되어 있는 정도

## 응집도의 종류(강한 순서)

- 기능적 응집도: 모듈 내부의 모든 기능 요소들이 단일 문제와 연관
- 순차적 응집도: 모듈의 출력을 다음 활동 입력으로 사용
- 교환적 응집도: 동일한 입력과 출력을 사용하여 서로 다른 기능 수행하는 구성 요소들이 모임
- 절차적 응집도: 모듈이 다수 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행
- 시간적 응집도: 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성
- 논리적 응집도: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성
- 우연적 응집도: 모듈 내부 요소들이 서로 관련 없는 요소로 구성

### N-S 차트

- 논리의 기술에 중점을 두고 도형을 이용해 표현

# 76. 단위 모듈

- 한 가지 동작을 수행하는 기능을 모듈로 구현
- 단위 기능 명세서 작성 -> 입출력 기능 구현 -> 알고리즘 구현

## IPC(Inter-Process Communication)

- <u>모듈 간 통신 방식</u>을 구현하기 위해 사용되는 대표적 프로그래밍 인터페이스 집합
- 대표 메소드 5가지
  - Shared Memory: 공유 가능한 메모리를 구성하여 다수 프로세스가 통신
  - Socket: 네트워크 소켓을 이용하여 네트워크를 경유하는 다수 프로세스 간의 통신
  - Semaphores: 공유 자원에 대한 접근 제어를 통해 통신
  - Pipes&named Pipes: 선입선출 형태의 파이프를 이용한 메모리를 프로세스 간 공유
  - Message Queueing: 메시지가 발생하면 이를 전달하는 방식으로 통신

## 단위 모듈 테스트

- 모듈이 정해진 기능을 정확히 수행하는지 검증

## 테스트 케이스

- 소프트웨어가 사용자 요구사항을 정확히 준수하는지 확인을 위한 테스트 항목 명세서

# 77. 공통 모듈

- 여러 프로그램에서 공통으로 사용할 수 있는 모듈

## 공통 모듈 명세 기법의 종류

- 정확성
- 명확성
- 완전성
- 일관성
- 추적성

# 78. 코드

- 자료의 분류, 조합, 집계, 추출을 용이하게 하기 위해 사용하는 기호

## 코드의 주요 기능

- 식별 기능
- 분류 기능
- 배열 기능
- 표준화 기능
- 간소화 기능

## 코드의 종류

- 순차 코드: 일정 기준에 따라 차례대로 일련번호 부여
- 블록 코드: 공통성이 있는 것끼리 블록으로 구분, 각 블록 내에서 일련번호 부여
- 10진 코드: 코드화 대상 항목을 0~9까지 10진 분할, 다시 각각에 대해 10진 분할
- 그룹 분류 코드: 대분류, 중분류, 소분류 등으로 그룹 별로 구분
- 연상 코드: 항목의 명칭이나 관계있는 숫자, 문자, 기호를 이용해 코드 부여
- 표의 숫자 코드: 항목의 성질(물리적 수치)을 그대로 코드에 적용
- 합성 코드: 2개 이상의 코드를 조합

# 79. 디자인 패턴

- 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

## 생성 패턴(Creational Pattern)

- 추상 팩토리(Abstract Factory): 인터페이스를 통해 서로 연관,의존하는 객체들의 그룹으로 생성하여
  추상적으로 표현
- 빌더(Builder): 작게 분리된 인스턴스를 건측 하듯이 조합하여 객체를 생성
- 팩토리 메소드(Factory Method): 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화
- 프로토타입(Prototype): 원본 객체를 복제하는 방법으로 객체를 생성
- 싱글톤(Singleton): 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 
  여러 프로세스가 동시에 참조 불가능

## 구조 패턴(Structural Pattern)

- 어댑터(Adapter): 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환
- 브리지(Bridge): 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성
- 컴포지트(Composite): 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다룰 때 사용
- 데코레이터(Decorator): 객체 간의 결합을 통해 능동적으로 기능들을 확장
- 퍼싸드(Facade): 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편히 사용
- 플라이웨이트(Flyweight): 인스턴스를 가능한 한 공유해서 사용함으로써 메모리를 절약
- 프록시(Proxy): 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행

## 행위 패턴(Behavioral Pattern)

- 책임 연쇄(Chain of Responsibility): 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태
- 커맨드(Command): 요청을 객체 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한
  정보를 저장하거나 로그에 남기는 패턴
- 인터프리터(Interperter): 언어에 문법 표현을 정의하는 패턴
- 반복자(Iterator): 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 중재자(Mediator): 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의
- 메멘토(Memento): 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공
- 옵서버(Observer): 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달
- 상태(State): 객체의 상태에 따라 동일한 동작을 다르게 처리
- 전략(Strategy): 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환
- 템플릿 메소드(Template Method): 상위 클래스에서 골격을 정의, 하위 클래스에서 세부 처리를 구체화
- 방문자(Visitor): 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성

# 86. 인터페이스 요구사항 검증

- 요구사항이 명세서에 잘 기술되었는지 검토하고 개발 범위의 기준인 베이스라인을 설정

## 요구사항 검증 방법

- 요구사항 검토: 결함 여부를 검토 담당자들이 수작업으로 분석
  - 동료검토: 요구사항 명세서를 작성자가 명세서 내용을 직접 설명하고 동료가 결함을 발견
  - 워크스루: 요구사항 명세러를 미리 배포하고 사전 검토 후 검토 회의
  - 인스펙션: 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함 발견
- 프로토타이핑: 견본품을 만들어 최종 결과물을 예측
- 테스트 설계: 요구사항은 테스트할 수 있도록 작성, 테스트 케이스로 이를 검토
- CASE 도구 활용: 일관성 분석을 통해 요구사항 변경사항의 추적, 분석, 관리, 표준 준수 여부 확인

## 인터페이스 요구사항 검증 주요 항목

- 완전성: 요구사항이 완전하게 반영되었는가
- 일관성: 요구사항이 일관성을 유지하는가
- 명확성: 모든 참여자가 요구사항을 명확히 이해하는가
- 기능성: 요구사항이 "무엇을"에 중점을 두는가
- 검증 가능성: 개발된 소프트웨어가 사용자 요구 내용과 일치하는지 검증 가능한가
- 추적 가능성: 요구사항 명세서와 설계서를 추적할 수 있는가
- 변경 용이성: 요구사항 명세서가 변경이 쉽도록 작성되었는가

# 89. 인터페이스 방법 명세화

## 시스템 연계 기술

1. DB Link
2. API/Open API
3. 연계 솔루션
4. Socket
5. WebService

## 인터페이스 통신 유형

- 단방향 
- 동기
- 비동기

## 인터페이스 처리 유형

- 실시간 방식
- 지연 처리 방식
- 배치 방식

# 90. 미들웨어 솔루션

- 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어

## DB(DataBase)

- 클라이언트에서 원격의 데이터베이스와 연결하는 미들웨어

## RPC(Remote Procedure Call)

- 원격 프로시저 호출로, 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어

## MOM(Message Oriented Middleware)

- 메시지 기반의 비동기형 메시지 전달하는 미들웨어

## TP-Monitor(Transaction Processing Monitor)

- 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어

## ORB(Object Request Broker)

- 코바 표준 스펙을 구현한 객체 지향 미들웨어

## WAS(Web Application Server)

- 동적인 컨텐츠를 처리하기 위한 미들웨어

# 92. 모듈 연계를 위한 인터페이스 기능 식별

- 모듈 연계: 모듈 간 데이터 교환을 위해 관계를 설정하는 것
- EAI(Enterprise Application Integration)
- ESB(Enterprise Service Bus)
- 웹 서비스(Web Service)

## EAI(Enterprise Application Integration)

- 기업 내 각종 애플리케이션 및 플랫폼 간의 상호 연동이 가능하게 해주는 솔루션
- **Point-to-Point**: 가장 기본적 / 1:1로 연결 / 변경 및 재사용 어려움
- **Hub & Spoke**: 허브 시스템을 통한 중앙 집중형 / 확장 및 유지보수 용이 / 허브 장애시 전체에 영향
- **Message Bus**: 애플리케이션 사시에 미들웨어를 두어 처리 / 높은 확장성, 대용량 처리
- **Hybrid**: Hub & Spoke 방식와 Message Bus 방식 혼합 / 데이터 병학 최소화

## ESB(Enterprise Service Bus)

- 애플리케이션 간의 표준 기반 인터페이스 제공하는 솔루션
- 서비스 중심 통합
- 애플리케이션과의 결합도를 약하게 유지
- 관리 및 유지 보안 유지 쉬움
- 높은 수준 품질 지원

## Web Service

- 네트워크의 정보를 표준화된 서비스 형태로 만들어 공유하는 기술
- SOAP: XML 기반의 메시지를 네트워크 상에서 교환하는 프로토콜
- UDDI: WSDL을 등록하여 서비스와 서비스 제공자를 검색하고, 접근하는데 사용
- WSDL: 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술학 ㅗ게시

# 95. 인터페이스 구현

- JSON(JavaScript Object Notation): 데이터 객체를 속성,값 의 쌍 형태로 표현하는 개방형 표준 포맷
- AJAX(Asynchronous JavaScript and XML): 클라이언트와 서버 간의 XML 데이터 비동기 통신 기술

# 99. 사용자 인터페이스

- 정보 제공, 전달
- 콘텐츠 상세적 표현, 전체적인 구성
- 모든 사용자가 편리하고 간편하게 사용

## 사용자 인터페이스 구분

- CLI(Command Line Interface): 명령과 출력이 텍스트 형태
- GUI(Graphical User Interface): 아이콘이나 메뉴를 마우스로 선택하여 작업 수행
- NUI(Natural User Interface): 사용자의 말이나 행동으로 기기 조작

## 사용자 인터페이스 기본 원칙

- **직관성**: 누구나 쉽게 이해하고 사용
- **유효성**: 사용자의 목적을 정확하고 완벽하게 달설
- **학습성**: 누구나 쉽게 배우고 익힐 수 있어야 함
- **유연성**: 사용자의 요구사항을 최대한 수용하고 실수 최소화

# 101. UI 설계 도구

- Wireframe: 대략적인 레이아웃에 대한 뼈대를 설계
- Mockup: 와이어프레임보다 실제 화면과 유사하게 만든 정적인 형태 모형
- Story Board: 와이어프레임에서 설명, 페이지 간 이동 흐름 등을 추가한 문서
- Prototype: 실제 구현된 것처럼 테스트가 가능한 동적인 형태 모형

# 103. 품질 요구사항

- ISO/IEC 9126: 소프트웨어 품질 특성과 평가를 위한 국제 표준
- ISO/IEC 25010: ISO/IEC 9126에 호환성과 보안성 강화
- ISO/IEC 12119: 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트 국제표준
- ISO/IEC 14598: 소프트웨어 품질의 측정과 평가에 필요 절차를 규정한 표준

## ISO/IEC 9126 소프트웨어 품질 특성

- 기능성(Functionality)
- 신뢰성(Reliability)
- 사용성(Usability)
- 효율성(Efficiency)
- 유지 보수성(Maintainability)
- 이식성(Portability)

# 105. HCI / UX / 감성공학

- HCI(Human Computer Interaction or Interface): 사람이 시스템을 편리하고 안전하게 사용할 수 있도록
  연구하고 개발하는 학문
- UX(User Experience): 사용자가 이용하면서 느끼고 생각하게 되는 총체적 경험
  - 주관성, 정황성, 총체성
- 감성공학: 제품이나 작업환경을 사용자의 감성에 알맞게 설계 및 제작하는 기술

# 106. 애플리케이션 테스트

- 애플리케이션에 잠재되어 있는 결함을 찾는 행위

## 애플리케이션 테스트의 기본 원리

- **완벽한 테스트 불가능**: 결함이 없다고 증명할 수 없음
- **파레토 법칙**: 애플리케이션의 20%의 코드에서 전체 결함의 80%가 발생
- **살충제 패러독스**: 동일한 테스트 케이스로 테스트 반복 시  더 이상 결함이 발견되지 않는 현상
- **테스팅은 정황의존**: 정황에 따라 테스트 결과가 달라지므로 정황에 따라 다르게 테스트 수행
- **오류-부재의 궤변**: 결함을 모두 제거해도 요구사항을 만족하지 않으면 품질이 높다고 할 수 없다
- **테스트와 위험은 반비례**: 테스트를 많이 할수록 미래 발생할 위험 감소
- **테스트의 점진적 확대**: 테스트는 작은 부분에서 점점 확대하며 진행
- **테스트의 별도 팀 수행**: 테스트는 개발자와 관계없는 별도의 팀에서 수행

# 107. 애플리케이션 테스트 분류

- **정적 테스트**: 명세서나 코드를 대상으로 분석
  - 워크스루, 인스펙션, 코드 검사 등
- **동적 테스트**: 프로그램을 실행하여 분석
  - 블랙박스 테스트, 화이트박스 테스트

## 테스트 기반에 따른 테스트

- 명세 기반 테스트: 명세를 빠짐없이 테스트 케이스로 작성하여 테스트
- 구조 기반 테스트: 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스 작성
- 경험 기반 테스트: 테스터의 경험에 기반한 테스트

## 시각에 따른 테스트

- 검증 테스트: 개발자 시각에서 제품 생산 과정 테스트
- 확인 테스트: 사용자 시각에서 생산된 제품 결과 테스트

## 목적에 따른 테스트

- Recovery 테스트: 올바르게 복구되는지 테스트
- Security 테스트: 시스템을 보호할 수 있는지 테스트
- Stress 테스트:  과부하 시 정상적으로 동작하는지 테스트
- Performance 테스트: 실시간 성능이나 전체적 효율성 테스트
- Structure 테스트: 소프트웨어 내부의 논리적 경로, 소스 코드의 복잡성 등 테스트
- Regression 테스트: 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
- Parallel 테스트: 변경된 소프트웨어와 기존 소프트웨어에 동일 데이터를 입력해 결과를 비교하는 테스트

# 108. 테스트 기법에 따른 애플리케이션 테스트

## 화이트박스 테스트

- 원시 코드의 논리적 모든 경로를 테스트하여 테스트 케이스를 설계
- **기초 경로 검사**: 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
- **제어 구조 검사**
  - 조건 검사: 모듈 내의 논리적 조건을 테스트
  - 루프 검사: 프로그램의 반복 구조에 초점을 맞춰 테스트
  - 데이터 흐름 검사: 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 테스트

### 화이트박스 테스트의 검증 기준

- **문장** 검증 기준: 모든 **구문이** 한 번 이상 수행되도록 테스트 케이스 설계
- **분기** 검증 기준: 모든 **조건문에** 대해 조건식 결과가 True인 경우, False 경우를 한 번이상 테스트 케이스 설계
- **조건** 검증 기준: 조건문에 포함된 **개별 조건식**의 결과가 결과가 True인 경우, False 경우를 한 번이상 테스트 케이스 설계
- 분기/조건 기준: 분기 검증 기준과 조건 검증 기준을 모두 만족하는 설계

## 블랙박스 테스트

- 각 기능이 완전히 작동되는 것을 입증하는 테스트
- **동치 분할 검사**: 입력 조건에 타당한 자료와 타당하지 않은 자료의 개수를 균등하게 테스트 케이스로 정해 테스트
- **경계값 분석**: 경계값에서 오류가 발생할 확률이 높다는 점을 이용해, 입력 조건의 경계값을 테스트
- **원인-효과 그래프 검사**: 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석
- **오류 예측 검사**: 과거의 경험이나 확인잔의 감각으로 테스트
- **비교 검사**: 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일 결과가 나오는지 테스트

# 109. 개발 단계에 따른 애플리케이션 테스트

## 단위 테스트

- 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트

## 통합 테스트

- 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트

## 시스템 테스트

- 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는  테스트

## 인수 테스트

- 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트
- 사용자 인수 테스트
- 운영상의 인수 테스트
- 계약 인수 테스트
- 규정 인수 테스트
- 알파 테스트
- 베타 테스트

# 110. 통합 테스트

## 하향식 통합 테스트

- 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
- 깊이 우선 통합법 / 넓이 우선 통합법
- 주요 제어 모듈의 종속 모듈들은 "스텁(Stub)"으로 대체

## 상향식 통합 테스트

- 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트
- 하위 모듈들을 "클러스터(Cluster)"로 결합
- 더미 모듈인 "드라이버(Driver)"를 작성

## 혼합식 통합 테스트

- 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트 지원

## 회귀 테스팅(Regression Testing)

- 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 테스트

# 테스트 케이스/시나리오/오라클

- 테스트 케이스: 사용자의 요구사항을 정확하게 준수했는지 확인
- 테스트 시나리오: 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트케이스를 묶은 집합
- 테스트 오라클: 테스트 결과가 올바른지 확인을 위해 사전에 정의된 참값을 대입하여 비교
  - 참(Ture) 오라클: 모든 테스트 케이스의 입력 값에 대해 기대하는 결과 제공
  - 샘플링(Sampling) 오라클: 특정 몇몇 테스트 케이스의 입력 값에 대해 기대하는 결과 제공
  - 추정(Heuristic) 오라클: 특정 몇몇 테스트 케이스의 입력 값에 대해 기대하는 결과 제공하고 나머지는 추정으로 처리
  - 일관성 검사(Consistent) 오라클: 애플리케이션 변경 시 테스트 케이스 수행 전과 후 결과 값이 동일한지 비교

# 115. 애플리케이션 성능 분석

- 처리량(Throughput): 일정 시간 내 처리하는 일의 양
- 응답 시간(Response Time): 애플리케이션에 요청했을 때 응답까지 걸린 시간
- 경과 시간(Turn Around Time): 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
- 자원 사용률(Resource Usage): 애플리케이션이 의뢰한 작업을 처리하는 동안의 자원 사용률

# 116. 복잡도

## 시간 복잡도

- 빅오 표기법: 최악일 떄 표기법
- 세타 표기법: 평균일 때 표기법
- 오메가 표기법: 최상일 때 표기법

# 117. 애플리케이션 성능 개선

- 스파게티 코드: 코드의 로직이 서로 복잡하게 얽힌 코드
- 외계인 코드: 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수가 어려운 코드

## 클린 코드 작성 원칙

- 가독성: 누구든지 코드를 쉽게 읽을 수있도록 작성
- 단순성: 코드를 간단하게 작성
- 의존성 배제: 코드가 다른 모듈에 미치는 영향을 최소화
- 중복성 최소화: 코드 중복 최소화
- 추상화: 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고
  상세 내용은 하위 클래스/메소드/함수에서 구현

# 118. SQL - DDL

## DDL(Data Define Language, 데이터 정의어)

- DB를 구축하거나 수정할 목적으로 사용하는 언어
- 번역한 결과가 데이터 사전(Data Dictionary)에 저장
- DDL 유형
  - CREATE
  - ALTER
  - DROP

## CREATE SCHEMA

- CREATE SCHEMA 스키마명 AUTHORIZATION 사용자_id;

## CREATE DOMAIN

- CREATE DOMAIN 도메인명 [AS] 데이터_타입
  	[DEFAULT 기본값]
  	[CONSTRAINT 제약조건명 CHECK (범위값)];

## CREATE TABLE

- CREATE TABLE 테이블명
  		(속성명 데이터_타입 [DEFAULT 기본값] [NOT NULL]),
    		[, PRIMARY (기본키_속성명,)] - 기본키 지정
    		[, UNIQUE(대체키_속성명,)] - 대체키 지정(중복값 불가)
    		[, FOREIGN KEY(외래키속성명, )] - 외래키 지정
    		[REFERENCES 참조테이블(기본키_ 속성명,)] 
    		[ON DELETE 옵션]
    		[ON UPDATE 옵션]
    		[, CONSTRAINT 제약조건명] [CHECK (조건식)]; - 제약조건

## CREATE VIEW

- CREATE VIEW 뷰명[(속성명[, 속성명, ])]
  		AS SELECT문;

## CREATE INDEX

- CREATE [UNIQUE] INDEX 인덱스명
  		ON 테이블명(속성명 [ASC | DESC] [, 속성명 [ASC | DESC]])
    		[CLUSTER]; - 클러스터드 인덱스로 지정

## ALTER TABLE

- ATLER TABLE 테이블명 ADD 속성명 데이터_타입 [DEFAULT '기본값'];
- ATLER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];
- ATLER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];

## DROP

- DROP SCHEMA 스키마명 [CASCADE | RESTRICT];
- DROP DOMAIN 도메인명 [CASCADE | RESTRICT];
- DROP TABLE 테이블명 [CASCADE | RESTRICT];
- DROP VIEW 뷰명 [CASCADE | RESTRICT];
- DROP INDEX 인덱스명 [CASCADE | RESTRICT];
- DROP CONSTRAINT 제약조건명;
- CASCADE - 요소 제거시 참조 중인 모든 개체를 함께 제거
- RESTRICT - 참조중일 때는 제거를 취소

# 119. SQL - DCL

## DCL(Data Control Language, 데이터 제어어)

- 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의
- 데이터베이스 관리자가 데이터 관리를 목적으로 사용
- DCL 종류
  - COMMIT: 트랜잭션이 수행한 내용을 데이터베이스에 반영
  - ROLLBACK: 변경되었으나 아직 COMMIT 되지 않은 모든 내용들을 취소하고 데이터 베이스를 되돌림
  - GRANT: 권한 부여
  - REVOKE: 권한 취소 (SAVEPOINT: 롤백 저장점)

## GRANT / REVOKE

- 사용자 등급 지정 및 해제
  - GRANT 사용자등급 TO 사용자_ID_리스트 [IDENTIFIED BY 암호]; - 권한 부여
  - REVOKE 사용자등급 FROM 사용자_ID_리스트; - 권한 취소
- 테이블 및 속성 권한 부여 및 해제
  - GRANT 권한_리스트 ON 개체 TO 사용자 [WITH_GRANT OPTION];
    - WITH_GRANT OPTION - 다른 사용자에게 다시 권한 부여 가능
  - REVOKE [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사용자 [CASCADE];
    - GRANT OPTION FOR - 다른 사용자에게 권한 부여할 수  있는 권한 취소
    - CASCADE: 다른 사용자에게 부여한 권도 연쇄적 취소

# 120. SQL - DML

## DML(Data Manipulation Language, 데이터 조작어)

- 저장된 데이터를 실질적으로 관리하는데 사용되는 언어
- DML 유형
  - SELECT: 튜풀 검색
  - INSERT: 튜플 삽입
  - DELETE: 튜플 삭제
  - UPDATE: 튜플 내용 갱신

## 삽입문(INSERT INTO~)

- INSERT INTO 테이블명([속성명1, 속성명2,])
  VALUES (데이터1,데이터2,)

## 삭제문(DELETE FROM~)

- DELETE
  FROM 테이블명
  [WHERE 조건];

## 갱신문(UPDATE~ SET~)

- UPDATE 테이블명
  SET 속성명 = 데이터[, 속성명=데이터, ]
  [WHERE 조건];

# 121. DML - SELECT - 1

- SELECT [PREDICATE] [테이블명,] 속성명 [AS 별칭] [[테이블명]속성명,]
  [, 그룹함수 (속성명) [AS 별칭]]
  [, Window함수 OVER (PARTITION BY 속성명1, 속성명2,...
  		ORDER BY 속성명3, 속성명4,...)]
  FROM 테이블명[테이블명,...]
  [WHERE 조건]
  **[GROUP BY 속성명, 속성명, ...]**
  **[HAVING 조건]**
  [ORDER BY 속성명 [ASC | DESC]];
- PREDICATE - 검색할 튜플 수 제한
- HAVING - GROUP BY의 조건 지정
- LIKE 연산자 - %(모든 문자) / _(문자 하나) / #(숫자 하나)
- 그룹 함수
  - COUNT(속성명): 그룹별 튜플 수 
  - SUM(속성명): 그룹별 합계
  - AVG(속성명): 그룹별 평
  - MAX(속성명): 그룹별 최대값
  - MIN(속성명): 그룹별 최소값
  - STDDEV(속성명): 그룹별 표준편차
  - VARIANCE(속성명): 그룹별 분산
  - ROLLUP(속성명1, 속성명2,...): 그룹별 소계로 하위 레벨에서 상위레벨 순으로 데이터가 집계됨
  - CUBE(속성명, 속성명, ...): 모든 조합의 그룹별 소계를 구함
- WINDOW 함수
  - 함수의 인수로 지정한 속성의 값을 집계
    - ROW_NUMBER(): 윈도우별 각 레코드에 대한 일련번호 반환
    - RANK(): 윈도우별로 순위 반환, 공동 순위 반영
    - DENSE_RANK(): 윈도우별 순위 반환, 공동 순위 무시
- 집합 연산자
  - UNION - 합집합(중복된 행은 한 번 출력)
  - UNION ALL - 합집합(중복된 행도 그대로 출력)
  - INTERSECT - 교집합
  - EXCEPT - 차집합(첫번째 조회 결과에서 두번째 조회 결과를 제외하고 출력)

# 123. DML - JOIN

## JOIN

- 2개의 릴레이션에서 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환

## INNER JOIN

- EQUI JOIN: '='을 이용해 같은 값을 가지는 행을 연결하여 결과를 생성
- SELECT 절에서 WHERE 사용
  - WHERE 테이블명1.속성명 = 테이블명2.속성명;
- SELECT 절에서 NATURAL JOIN 사용
  - FROM 테이블명1 NATURAL JOIN 테이블명2;
- SELECT 절에서 JOIN~USING 절을 이용
  - FROM 테이블명1 JOIN 테이블명2 USING(속성명);

## OUTER JOIN

- JOIN 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN 방법

- LEFT OUTER JOIN

  - INNBER JOIN 결과에서 우측  항 릴레이션 어느 튜플과도  맞지 않는 좌측 항에 있는 튜플들에 NULL값을 붙여 추가
  - FROM 테이블명1 LEFT OUTER JOIN 테이블명2
    ON 테이블명1.속성명 = 테이블명2.속성명;
  - FROM 테이블명1, 테이블명2
    WHERE 테이블명1.속성명 = 테이블명2. 속성명(+);

- RIGHT OUTER JOIN

  - INNBER JOIN 결과에서 좌측  항 릴레이션 어느 튜플과도  맞지 않는 우측 항에 있는 튜플들에 NULL값을 붙여 추가

  - FROM 테이블명1 RIGHT OUTER JOIN 테이블명2
    ON 테이블명1.속성명 = 테이블명2.속성명;

  - FROM 테이블명1, 테이블명2

    WHERE 테이블명1.속성명(+) = 테이블명2. 속성명;

- FULL OUTER JOIN

  - FROM 테이블명1 FULL OUTER JOIN 테이블명2
    ON 테이블명1.속성명 = 테이블명2.속성명;

# 124. 프로시저(Procedure)

## 프로시저(Procedure)

- SQL을 사용하여 작성한 일련의 작업을 저장해두고 호출을 통해 
  원할 때마다 저장한 작업을 수행하도록 하는 절차형 SQL

### 프로시저 구성

- DECLARE (필수)
  	CONTROL
  	SQL
  	EXCEPTION
  	TRANSACTION
  END (필수)

## 프로시저 생성

- CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터)
  [지역변수 선언]
  BEGIN
  	프로시저 BODY;
  END;
- OR REPLACE: 동일한 이름의 프로시저가 존재하면 기존의 프로시저 대체

## 프로시저 실행

- EXECUTE 프로시저명;
- EXEC 프로시저명;
- CALL 프로시저명;

## 프로시저 제거

- DROP PROCEDURE 프로시저명;

# 125. 트리거(Trigger)

## 트리커(Trigger)

- 이벤트가 발생할 때 관련 작업이 자동으로 수행되게 하는 절차형 SQL
- 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등

## 트리거 구성

- DECLARE (필수)

  EVENT (필수)
  	CONTROL
  	SQL
  	EXCEPTION
  END (필수)

## 트리거 생성

- CREATE [OR REPLACE] TRIGGER 트리거명 [동작시기 옵션] [동작 옵션] ON 테이블명
  REFERENCING [NEW | OLD] AS 테이블명
  FOR EACH ROW
  [WHEN 조건식]
  BEGIN
  	트리거 BODY;
  END;
- 동작 시기 옵션: 트리거가 실행될 때를 지정
  - AFTER
  - BEFORE
- NEW | OLD: 트리거가 적용될 테이블의 별칭을 지정
  - NEW
  - OLD
- FOR EACH ROW: 각 튜플마다 트리거를 적용한다는 의미
- WHEN 조건식: 트리거를 적용할 튜플의 조건을 지정
- 트리거 BODY: 트리거의 본문 코드 입력

## 트리거 제거

- DROP TRIGGER 트리거명;

# 126. 사용자 정의 함수

- 프로시저와 유사하나 종료 시 처리 결과로 단일값만을 반환하는 절차형 SQL

## 사용자 정의 함수 구성

- DECLARE (필수)

  EVENT (필수)
  	CONTROL
  	SQL
  	EXCEPTION
  	RETURN (필수)

  END (필수)

## 사용자 정의 함수 생성

- CREATE [ORE REPLACE] FUNCTION 사용자 정의 함수명(파라미터)
  [지역변수 선언]
  BEGIN
  	사용자 정의 함수 BODY;
  	RETURN 반환값;
  END;

## 사용자 정의 함수 실행

- SELECT 사용자정의함수명 FROM 테이블명;
- INSERT INTO 테이블명(속성명) VALUES (사용자정의함수명);
- DELETE FROM 테이블명 WHERE 속성명 = 사용자정의함수명;
- UPDATE 테이블명 SET 속성명 = 사용자정의함수명

## 사용자 정의 함수 제거

- DROP FUNCTION 사용자정의함수명;

# 127. 제어문

## IF문

- IF 조건 THEN
  	실행할 문장 1;
  END IF;

## LOOP문

- LOOP
  	실행할 문장;
  	EXIT WHEN 조건;
  END LOOP;

# 128. 커서(Cursor)

## 커서(Cursor)

- 쿼리문의 처리 결과가 저장되어 있는 메모리 공간을 가리키는 포인터

## 묵시적 커서(Implicit Cursor)

- DBMS 내부에서 자동으로 생성되어 사용되는 커서
- SQL%FOUND: 쿼리 수행 결과로 패치된 튜플 수가 1개 이상이면 TRUE
- SQL%NOTFOUND: 쿼리 수행 결과로 패치된 튜플 수가 0개이면 TRUE
- SQL%ROWCOUNT: 쿼리 수행 결과로 패치된 튜플 수를 반환
- SQL%ISOPEN: 커서가 열린 상태이면 TRUE

## 명시적 커서(Explicit Cursor)

- 사용자가 직접 정의해서 사용하는 커서
- 기본적으로 '열기(OPEN) => 패치(Fetch) => 닫기(Close)' 순서
- 선언(Declare) 형식
  - CURSOR 커서명(매개변수1, 매개변수2, ...)
    IS
    SELECT문;
- 열기(OPEN) 형식
  - OPEN 커서명(매개변수1, 매개변수2, ...);
- 패치(FETCH) 형식
  - FETCH 커서명 INTO 매개변수1, 매개변수2, ...;
- 닫기(CLOSE)  형식
  - CLOSE 커서명;

# 129. DBMS 접속

## DBMS 접속

- 응용 시스템을 이용하여 DBMS에 접근하는 것
- 응용 시스템
- 웹 응용 시스템: 웹서버 + 웹 애플리케이션 서버

## DBMS 접속 기술

- JDBC(Java DataBase Connectivity): 자바에서 데이터베이스 접속 시 사용하는 표준 API
- ODBC(Open DataBase Connectivity): 개발 언어에 관계없이 데이터베이스에 접근하기 위한 표준 개발 API
- MyBatis: SQL Mapping 기반 오픈 소스 접속 프레임워크

## 동적 SQL

- SQL 구문을 동적으로 변경하여 처리할 수 있는 SQL 처리 방식

# 130. SQL 테스트

- SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증하는 과정

## 단문 SQL 테스트

- DDL, DML, DCL이 포함되어 있는 SQL과 TCL을 테스트하는 것
- DDL로 작성된 개체는 DESCRIBE 명령어를 이용하여 속성, 자료형, 옵션들을 확인
  - DESC [개체명];
- DML로 변경한 데이터는 SELECT문으로 데이터의 정상적인 변경 여부를 확인
- DCL로 설정된 사용자 권한은 사용자 권한 정보가 저장된 테이블을 조회

## 절차형 SQL 테스트

- SHOW 명령어를 통해 오류 내용 확인
  - SHOW ERRORS;

# 131. ORM(Object-Relational Mapping)

- 객체와 관계형 데이터베이스의 데이터를 연결하는 기술

# 132. 쿼리 성능 최적화

## 옵티마이저

- RBO(Rule Based Optimizer): 규칙에 정의된 우선순위 기준
- CBO(Cost Based Optimizer): 엑세스 비용 기준

# 133. Secure SDLC

- SDLC에 보안강화를 위한 프로세스를 포함한 것
- 대표적인 방법론
  - CLASP
  - SDL
  - Seven Touchpoints

## SDLC 단계별 보안 활동

1. 요구사항 분석 단계
2. 설계 단계
3. 구현 단계
4. 테스트 단계
5. 유지보수 단계

## 소프트웨어 개발 보안 요소

- 기밀성(Confidentiality): 인가된 사용자에게만 접근 허용
- 무결성(Integrity): 오직 인가된 사용자만 수정가능
- 가용성(Availability): 인가받은 사용자는 시스템 내 정보,자원을 언제라도 사용가능
- 인증(Authentication): 사용자가 합법적인 사용자인지 확인
- 부인 방지(NonRepudiation):데이터를 송수신한 자가 그 사실을 부인할 수 없도록 증거 제공

## Secure Coding

- 구현 단계에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 보안 요소들을 고려하여 코딩하는 것

# 134. 세션 통제

- 세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것
- 세션 통제의 보안 약점
  - 불충분한 세션 관리
  - 잘못된 세션에 의한 정보 노출

# 135. 입력 데이터 검증 및 표현

- 구현 단계에서 검증해야 하는 보안 점검 항목들
- SQL 삽입: SQL삽입을 통해 내부 DB서버 데이터를 유출, 변조,인증 우회 등 보안 약점
- 경로 조작 및 자원 삽입: 데이터 입출력 경로 조작을 통해 서버 자원 수정,삭제
- 크로스사이트스크립팅: 웹페이지에 악의적인 스크립트를 삽입
- 운영체제 명령어 삽입: 외부 입력값을 통해 시스템 명령어의 실행 유도
- 위험한 형식 파일 업로드: 악의적인 명령어가 포함된 스크립트 파일을 업로드
- 신뢰하지 않는 URL 주소로 자동접속 연결: 입력 값으로 사이트 주소를 받는 경우 이를 조작
- 메모리 버퍼 오버플로: 할당된 메모리 범위를 넘어선 위치에서 자료를 읽거나 쓸 때 발생

# 136. 보안 기능

- 적절한 인증없이 중요기능 허용
- 부적절한 인가
- 중요한 자원에 대한 잘못된 권한 설정
- 취약한 암호화 알고리즘 사용
- 중요정보 평문 저장 및 전송
- 하드코드된 암호화 키

# 137. 시간 및 상태

- 병렬 처리 시스템이나 다수 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리

## 시간 및 상태의 보안 약점

- TOCTOU 경쟁 조건: 검사 시점과 사용 시점을 고려하지 않고 코딩할 때 발생
- 종료되지 않는 반복문 또는 재귀 함수: 종료 조건을 정의하지 않았을 때 발생

# 139. 코드 오류

- 널 포인터 역참조
- 부적절한 자원 해제
- 해제된 자원 사용
- 초기화되지 않은 변수 사용

## 스택 가드

- 널 포인터 역참조 같이 주소가 저장되는 스택에서 발생하는 보안 약점을 막는 기술

# 140. 캡슐화

- 잘못된 세션에 의한 정보 노출
- 제거되지 않고 남은 디버그 코드
- 시스템 데이터 정보 노출
- Public 메소드로부터 반환된 Private 배열
- Priavte 배열에 Public 데이터 할당

## 접근 제어자

| 접근 제어자 | 클래스 내부 | 패키지 내부 | 하위 클래스 | 패키지 외부 |
| ----------- | :---------: | :---------: | :---------: | :---------: |
| Public      |      ○      |      ○      |      ○      |      ○      |
| Protected   |      ○      |      ○      |      ○      |      ×      |
| Default     |      ○      |      ○      |      ×      |      ×      |
| Private     |      ○      |      ×      |      ×      |      ×      |

# 141. API 오용

- DNS Lookup에 의존한 보안 결정
- 취약한 API 사용

# 142. 암호 알고리즘

- 암호화 방식
  - 양방향
    - 개인키 - Stream 방식 / Block 방식
    - 공개키
  - 단방향 - HASH

## 개인키 암호화 방식

- 스트림 암호화 - LFSR / RC4
- 블록 암호화 
  - SEED - 한국인터넷진흥원에서 개발
  - ARIA - 국가정보원과 산학연협회가 개발
  - DES - 미국 NBS에서 개발 / 블록 크기 64비트 / 키 길이 56비트 / 16회 라운드
  - AES - NIST에서 발표 / 블록 크기 128비트

## 공개키 암호화 방식

- RSA - MIT에서 제안 / 큰 숫자를 소인수 분해 어렵다는 것에 기반

## 해시(Hash)

- 임의의 길이의 입력 데이나 메시지를 고정된 길이의 값이나 키로 변환하는 것
- SHA 시리즈 - NSA이 설계, NIST에 의해 발표
- MD5 - 블록 크기 512빙트 / 키 길이 128비트
- N-NASH - NTT에서 발표 / 블록 크기와 키 길이가 모두 128비트
- SNEFUR - R.C.Merkle가 발표

# 143. 서비스 공격 유형

## 서비스 거부(Dos: Denial of Service) 공격

- 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써, 표적이 되는 서버의 정상적 기능을 방해

### Ping of Death(죽음의 핑)

- 명령 전송 시 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비

### SMURFING(스머핑)

- IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적을 보냄으로써 
  네트워크를 불능 상태로 만드는 공격 방법

### SYN Flooding

- 공격자가 가상의 클라이언트로 위장하여 3-way-handshake 과정을 의도적으로 중단시켜
  공격 대상지 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법

### TearDrop

- Fragment Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부하를 발생시킴으로써
  시스템이 다운되도록 하는 공격 방법

### LAND Attack(Local Area Network Denial Attack)

- 패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격 대상에게 전송

### DDoS(Distributed Denial of Service, 분산 서비스 거부)공격

- 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행하는 것

## 네트워크 침해 공격 관련 용어

### 세션 하이재킹(Session Hijacking)

- 접속해 있는 서버와 클라이언트 사이의 세션 정보를 가로채는 공격

### ARP 스푸닝(ARP Spoofing)

- 자신의 물리적 주소(MAC)를 공격대상의 것으로 변조하여 공격 대상에게 도달해야 하는
  데이터 패킷을 가로채거나 방해

### 스미싱(Smishing)

- 문자 메시지를 이용해 사용자의 개인 신용 정보를 빼내는 수법

### 스피어 피싱(Spear Phishing)

- 일반적인 이메일로 위장한 메일을 발송하여 개인 정보 탈취

### APT(Advanced Persistent Threats, 지능형 지속 위협)

- 내부자에게 악성코드 이메일 전송 / 악성코드가 담긴 이동식 디스크 / 악성코드 감염된 P2P사이트 접속

### 무작위 대입 공격(Brute Force Attack)

- 적용 가능한 모든 값을 대입하여 공격

### 큐싱(Qshing)

- QR코드를 통한 피싱

### SQL 삽입 공격

- 취약한  사이트에서 데이터 베이스 등의 데이터를 조작

### 크로시트 사이트 스크립팅(XSS)

- 웹페이지 내용을 표현하는 스크립트의 취약점을 악용

### 스니핑(SNIFFING)

- 네트워크 중간에서 남의 패킷 정보를 도청

## 정보 보안 침해 공격 관련 용어

- 좀비 PC: 악성코드에 감염된 PC
- C&C 서버: 좀비PC에 명령을 내리고 악성코드를 제어하기 위한 원격 서버
- 봇넷(BOTNET): 악성 프로그램에 감염된 다수의 컴퓨터들이 네트워크로 연결된 형태
- 웜(WORM): 네트워크를 통해 연속적으로 자신을 복제하여 시스템의 부하를 높이는 바이러스
- 제로 데이 공격: 보안 취약점 발견 시 널리 공표되기 전에 재빨리 취약점을 이용해 보안공격
- 키로거 공격: 사용자의 키보드 움직임을 탐지
- 랜섬웨어: 사용자 컴퓨터에 잠입해 파일 등을 암호화 하여 열지 못하게 하는 프로그램
- 백도어: 시스템 설계자나 서비스 기술자 등이 유지보수를 위해 시스템 보안을 제거하여 만들어 놓은 비밀 통로
- 트로이 목마: 정상적인 프로그램인 척 숨어 있다가 해당 프로그램이 실행되면 부작용을 일으킴

# 144. 서버 인증

- 보안 서버: 개인 정보를 암호화하여 송수신할 수 있는 기능을 갖춘 서버
- 인증: 로그인을 요청하여 사용자의 정보를 확인하고, 접근 권한을 검증하는 보안 절차

## 지식 기반 인증

- 사용자가 기억하고 있는 정보 기반
- 고정된 패스워드: 접속 시 마다 입력
- 패스 프레이즈: 길이가 길고 기억하기 쉬운 문장 활용
- 아이핀: 사이버 주민등록번호

## 소유 기반 인증

- 사용자가 소유하고 있는 것 기반
- 신분증
- 메모리 카드
- 스마트 카드
- OTP

## 생체 기반 인증

- 사용자의 고유한 생체 정보 기반
- 지문, 홍채/망막, 얼굴, 음성, 정맥 등

## 기타 인증 방법

- 행위 기반 인증 - 서명, 동작
- 위치 기반 인증 - 콜백, GPS 또는 IP주소 활용

# 147. 보안 솔루션

- 방화벽: 내부 네트워크와 인터넷 간 정보 선별하여 수용,거부,수정
- 침입 탐지 시스템(IDS): 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간 탐지
  - 오용 탐지: 미리 입력해 둔 공격 패턴 감지 시 알림
  - 이상 탐지: 평균적인 시스템 상태 기준 비정상적인 사용 감지
- 침입 방지 시스템(IPS): 비정상적인 트래픽을 능동적으로 차단하고 격리
- 데이터 유출 방지(DLP): 내부 정보의 외부 유출을 방지
- 웹 방화벽: 웹 기반 공격을 방어
- VPN(가상 사설 통신망): 사용자가 마치 전용 회선을 사용하는 것처럼 함
- NAC: 네트워크 접속하는 내부 PC의 MAC주소를 IP관리 시스템에 등록한 후 일관된 보안 관리 기능 제공
- ESM: 다양한 장비의 로그 및 보안 이벤트를 종합하여 관리

# 149. 데이터 입출력

- 헝가리안 표기법: 변수명 작성 시 변수의 자료형을 의미하는 문자를 포함하여 작성

## C언어

- #include <stdio.h>
  scanf("%d", &i);
  printf("%d", k);

## 자바

- import java.util.Scanner;
  Scanner scan = new Scanner(System.in);
  int a = scan.nextInt();
  System.out.printf("%d", a);
  scan.close();

## 주요 자료형

| 종류   | 자료형 | 크기(C) | 크기(Java) |
| ------ | ------ | ------- | ---------- |
| 정수형 | int    | 4Byte   | 4Byte      |
| 문자형 | char   | 1Byte   | 2Byte      |
| 실수형 | float  | 4Byte   | 4Byte      |
| 실수형 | double | 8Byte   | 8Byte      |

### 주요 서식 문자열

| 서식 문자열 | 의미                 |
| ----------- | -------------------- |
| %d          | 10진수               |
| %o          | 8진수                |
| %x          | 16진수               |
| %c          | 문자                 |
| %s          | 문자열               |
| %f          | 소수점을 포함한 실수 |

### 주요 제어문자

| 제어문자 | 기능                           |
| -------- | ------------------------------ |
| \n       | 커서를 다음 줄의 처음으로 이동 |
| \t       | 커서를 일정 간격 띄움          |
| \0       | 널 문자 출력                   |

### 연산자 우선순위

| 대분류      | 중분류        | 연산자                                                 | 결합규칙 | 우선 순위 |
| ----------- | ------------- | ------------------------------------------------------ | -------- | --------- |
| 단항 연산자 | 단항 연산자   | !(논리 not) ~(비트 not) ++(증가) --(감소) sizeof(기타) | ←        | 높음      |
| 이항 연산자 | 산술 연산자   | * / %<br />+-                                          | →        |           |
| 이항 연산자 | 시프트 연산자 | << >>                                                  | →        |           |
| 이항 연산자 | 관계 연산자   | < <= >= ><br />== !=                                   | →        |           |
| 이항 연산자 | 비트 연산자   | &(비트 and)<br />^(비트 xor)<br />\ (비트 or)          | →        |           |
| 이항 연산자 | 논리 연산자   | &&(논리 and)<br />\|\|(논리 or)                        | →        |           |
| 삼항 연산자 | 조건 연산자   | ? :                                                    | →        |           |
| 대입 연산자 | 대입 연산자   | = += -= *= /= %= <<= >>= 등                            | ←        |           |
| 순서 연산자 | 순서 연산자   | ,                                                      | →        | 낮음      |

# 157. 절차적 프로그래밍 언어

- 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술하는 언어

## 절차적 프로그래밍 언어 종류

- C: 1972년 미국 벨 연구소에서 개발
- ALGOL: 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어
- COBOL: 사무 처리용 언어
- FORTRAN: 과학 기술 계산용 언어

# 158. 객체지향 프로그래밍 언어

- 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어 기계의 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 프로그램을 작성하는 기법
- 프로시저보다는 명령과 데이터로 구성된 객체를 중심

## 객체지향 프로그래밍 언어 종류

- JAVA: 운영체제 및 하드웨어에 독립적
- C++: C언어에 객체지향 개념 적용
- Smalltalk: 1세대 객체지향 프로그래밍 언어로, 최초로 GUI 제공

# 159. 스크립트 언어

- HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 언어
- 별도의 번역기를 소스가 분석하여 동작

## 스크립트 언어 분류

- 서버용 스크립트 언어: 서버에서 해석되어 실행된 후 결과를 클라이언트로 보냄
  - ASP, JSP, PHP, 파이썬
- 클라이언트용 스크립트 언어: 클라이언트의 웹 브라우저에서 해석되어 실행
  - 자바 스크립트, VB 스크립트

# 160. 선언형 언어

- 프로그램이 수행해야 할 문제를 기술하는 언어

## 선언형 언어 분류

- 함수형 언어: 수학적 함수를 조합하여 문제를 해결
  - LISP
- 논리형 언어: 기호 논리학에 기반, 논리 문장을 이용하여 프로그램을 표현하고 계산 수행
  - PROLOG

## 선언형 언어 종류

- HTML: 인터넷 표준 문서
- LISP: 인공지능 분야에서 사용, 기본 자료 구조가 연결 리스트
- PROLOG: 논리학을 기초로한 고급 언어
- XML: 웹에서 다양한 문서를 상호 교환
- Haskell: 함수형 프로그래밍 언어 부작용이 없음

## 명령형 언어

- 문제를 해결하기 위한 방법을 기술하는 어너
- 폰노이만 구조에 개념적인 기초
- 종류: FORTRAN, COBOL, C, JAVA

# 161. 라이브러리

- 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체
- 표준 라이브러리와 외부 라이브러리가 있음

## C언어 표준 라이브러리

- stdio.h: 데이터 입출력
- math.h: 수학 함수
- string.h: 문자열 처리
- stdlib.h: 자료형 반환, 난수 발생, 메모리 할당 등
- time.h: 시간 처리

## Java의 표준 라이브러리

- java.lang: 인터페이스, 자료형, 예외 처리 등 / import문 필요 없음
- java.util: 날짜 처리, 난수 발생, 복잡한 문자열 처리 등
- java.io: 파일 입출력과 관련된 기능 및 프로토콜 
- java.net: 네트워크와 관련된 기능
- java.awt: 사용자 인터페이스와 관련된 기능

## Python 표준 라이브러리

- 내장 함수: 기본 인터페이스
- os: 운영체제와 상호작용을 위한 기능
- re: 고급 문자열 처리를 위한 기능
- math: 복잡한 수학 연산을 위한 기능
- random: 무작위 선택을 위한 기능
- statistics: 통계값 산출을 위한 기능
- datetime: 날짜와 시간 조작을 위한 기능

# 162. 예외 처리

## JAVA의 주요 예외 객체

- ClassNotFoundException: 클래스를 찾지 못한 경우
- NoSuchMethodException: 메소드를 찾지 못한 경우
- FileNotFoundException: 파일을 찾지 못한 경우
- InterruptedIOException: 입출력 처리가 중단된 경우
- ArithmeticException: 0으로 나누는 등 산술 연산에 대한 예외가 발생한 경우
- IllgalArgumentException: 잘못된 인자를 전달한 경우
- NumberFormatException: 숫자 형식으로 변환할 수 없는 문자열을 숫자 형식으로 변환한 경우
- ArrayIndexOutOfBoundsException: 배열의 범위를 벗어난 접근을 시도한 경우
- NegativeArraySizeException: 0보다 작은 값으로 배열의 크기를 지정한 경우
- NullPointerException: 존재하지 않는 객체를 참조한 경우

# 163. 운영체제의 개념

## 운영체제

- 컴퓨터 시스템의 자원 들을 효율적으로 관리하며,
  사용자가 편리하고 효과적으로 사용할 수 있도록 환경을 제공

## 운영체제의 목적

- **처리 능력**: 일정 시간 내에 시스템이 처리하는 일의 양
- **반환 시간**: 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
- **사용 가능도**: 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
- **신뢰도**: 시스템이 주어진 문제를 정확하게 해결하는 정도

## 운영체제의 기능

- 자원 관리
- 자원 스케줄링 기능
- 편리한 인터페이스
- 각종 하드웨어와 네트워크 관리,제어
- 데이터 및 자원 공유 기능 

# 164. 운영체제의 종류

## Windows

- GUI
- 선점형 멀티태스킹: 운영 체제가 각 작업의 CPU 이용 시간을 제어
- PnP: 하드웨어에 사용에 필요한 시스템 환경을 운영체제가 자동으로 구성
- OLE: 개체를 자유롭게 연결하거나 삽입
- 255자의 긴 파일명: \/*?"<>| 를 제외한 모든 문자 및 공백 사용하여 최대 255자 파일 이름 가능
- SIngle-User 시스템: 컴퓨터 한 대를 한 사람만이 독점해서 사용

## UNIX

- 시분할 시스템을 위한 대화식 운영체제
- 소스가 공개된 개방형 시스템
- 대부분 C언어로 작성
- 다중 사용, 다중 작업 지원
- 트리 구조의 파일 시스템

### UNIX 시스템 구성

- **커널**: 하드웨어를 보호하고, 프로그램과 하드웨어 간 인터페이스 역할
  - 프로세스 관리, 기억장치 관리
  - 파일 관리, 입출력 관리, 
  - 프로세스간 통신, 데이터 전송 및 변환
- **쉘**: 사용자의 명령어를 인식하여 프로그램을 호출하고 명령 수행하는 명령어 해석시
  - 시스템과 사용자 간의 인터페이스 담당
- **유틸리티 프로그램**: 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용
  - 에디터, 컴파일러, 인터프리터, 디버거 등

## LINUX

- UNIX 기반 개발
- 소스 코드 공개

## MacOS

- 애플이 개발한 UNIX 기반 운영체제

## Android

- 구글에서 개발한 리눅스 커널 기반 개방형 모바일 운영체제
- 자바와 코틀린으로 애플리케이션 개발

## iOS

- 애플이 개발한 UNIX 기반 모바일 운영체제

# 165. 기억장치 관리

## 반입(Fetch) 전략

- 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지 결정

- 요구 반입: 실행중인 프로그램이 데이터(프로그램)를 요구할 때 적재
- 예상 반입: 실행중인 프로그램이 사용할 데이터(프로그램)를 미리 예상하여 적재

## 배치(Placement) 전략

- 최초 적합: 들어갈 수있는 크기의 빈 영역 중 첫 번째 영역에 배치
- 최적 적합: 들어갈 수있는 크기의 빈 영역 중 단편화를 가장 작게 남기는 영역에 배치
- 최악 적합: 들어갈 수있는 크기의 빈 영역 중 단편화를 가장 많이 남기는 영역에 배치

## 교체(Replacement) 전략

- 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정

# 166. 주기억장치 할당 기법

## 연속 할당 기법 

- 프로그램을 주기억장치에 연속으로 할당

### 단일 분할 할당 기법

- 한순간에는 오직 한 명의 사용자만이 주기억장치의 사용자 영역을 사용
- 운영체제 영역과 사용자 영역을 구분하는 "경계 레지스터"사용
- **오버레이 기법**: 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
- **스와핑 기법**: 하나의 프로그램을 전체를 주기억장치에 할당하고, 필요에 따라 다른 프로그램과 교체

### 다중 분할 기법

- 고정 분할 할당 기법: 사용자 영역을 여러 개의 고정된 크기로 분할하고 프로그램을 각 영역에 할당
- 가변 분할 할당 기법: 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할

## 분산 할당 기법

- 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당
- 가상기억장치: 보조기억장치의 일부를 주기억장치처럼 사용

### 페이징 기법

- 프로그램과 주기억장치의 영역을 <u>동일한 크기</u>로 나눈 후, 나눠진 프로그램을 동일하게 나눠진
  주기억장치 영역에 적재시켜 실행
- 나눈 단위 -> 페이지
- 외부 단편화 발생 X / 내부 단편화 발생 가능

### 세그먼테이션 기법

- 프로그램을 <u>다양한 크기의 논리적 단위</u>로 나눈 후 주기억장치에 적재시켜 실행
- 나눈 단위 -> 세그먼트
- 내부 단편화 발생 X / 외부 단편화 발생 가능

# 168. 페이지 교체 알고리즘

- 페이지 부재 발생 시 어떤 페이지 프레임을 선택하여 교체할 것인가를 결정

## OPT(최적 교체)

- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체
- 페이지 부재 횟수가 가장 적게 발생

## FIFO(First In First Out)

- 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체

## LRU(Least Recently Used)

- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
- 즉 가장 오래 전에 사용된 페이지를 교체

## LFU(Least Frequently Used)

- 사용 빈도가 가장 적은 페이지를 교체

## NUR(Not Used Recently)

- 최근에 사용하지 않은 페이지를 교체
- 각 페이지마다 "참조 비트"와 "변형 비트"가 사용

## SCR(Second Chance Replacement, 2차 기회 교체)

- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지

# 169. 가상기억장치 기타 관리 사항

## 페이지 크기

### 페이지 크기가 작은 경우

- 페이지 단편화 감소
- 페이지 맵 테이블 크기 증가
- 매핑 속도가 늦어짐
- 전체적 입출력 시간 증가

### 페이지 크기가 클 경우

- 페이지 단편화 증가
- 페이지 맵 테이블 크기 감소
- 매핑 속도가 빨라짐
- 전체적 입출력 시간 감소

## Locality(구역성)

- 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질
- 시간 구역성: 하나의 페이지를 일정 시간 동안 집중적으로 액세스
- 공간 구역성: 일정 위치의 페이지를 집중적으로 액세스

## 워킹 셋(Working Set)

- 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합

## 스래싱(Thrashing)

- 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상

# 170. 프로세스의 개요

## PCB(Process Control Block)

- 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳

## 프로세스 상태 전이

1. 제출
2. 접수
3. 준비
4. 실행
5. 대기
6. 종료

- Dispatch: 준비 상태에서 실행 상태로 전이되는 과정
- Wake Up: 대기 상태에서 준비 상태로 전이되는 과정
- Spooling: 나중에 한꺼번에 입출력하기 위해 디스크에 저장하는 고정

## 스레드(Thread)

- 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위

# 171. 스케줄링

- 장기 스케줄링: 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가
- 중기 스케줄링: 어떤 프로세스가 CPU를 할당받을 것인지
- 단기 스케줄링: 프로세스 실행 전 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업

## 비선점 스케줄링

- 이미 할당된 CPU를 다른 프로세스가 강제로 뺴앗아 사용할 수 없는 스케줄링
- FCFS, SJF, 우선순위, HRN, 기한부 등

## 선점 스케줄링

- 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링
- 시분할 시스템에서 사용
- Round Robin, SRT, 선점 우선순위, 다단계 큐 다단계 피드백 큐 등

# 172. 주요 스케줄링 알고리줌

## FCFS(선입선출)

- 준비상태 큐에 도착한 순서에 따라 차례대로 CPU를 할당

## SJF(단기 작업 우선)

- 준비상태 큐에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU 할당

## HRN

- 대기 시간과 서비스 시간을 이용
- 우선순위 계산 = (대기 시간 + 서비스 시간) / 서비스 시간

# 173. 환경 변수

- 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임

# 174. 운영체제 기본 명령어

## Windows 기본 명령어

- DIR: 현재 디렉터리의 파일 목록 표시
- CORY: 파일 복사
- DEL: 파일 삭제
- TYPE: 파일 내용 표시
- REN: 파일 이름 변경
- MD: 디렉터리 생성
- CD: 디렉터리 위치 변경
- CLS: 화면 내용 지우기
- ATTRIB: 파일 속성 변경
- FIND: 파일에서 문자열 찾기
- CHKDSK: 디스크 상태 점검
- FORMAT: 디스크 표면을 트랙과 섹터로 나누어 초기화
- MOVE: 파일 이동

## UNIX/LINUX 기본 명령어

- cat: 파일 내용 표시
- cd: 디렉터리 위치 변경
- chmod: 파일 사용 허가 지정
- chown: 파일 소유자와 그룹 변경 rwx 소유자 / 그룹 / 기타 사용자
- cp: 파일 복사
- rm: 파일 삭제
- find: 파일 찾음
- fsck: 파일 시스템을 검사하고 보수
- kill: PID로 프로세스 종료
- fork: 새로운 프로세스 생성
- killall: 프로세스 종료
- ls: 현재 디렉터리의 파일 목록 표시
- mkdir: 디렉터리 생성
- rmdir: 디렉터리 삭제
- mv: 파일 이동
- ps: 현재 실행중인 프로세스 표시
- pwd: 현재 작업중인 디렉터리 경로 표시
- top: 시스템의 프로세스와 메모리 사용 현황 표시
- who: 현재 시스템에 접속해 있는 사용자 표시

# 175. 인터넷

- 전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망

## IP 주소

- 8비트 * 4부분 = 32비트

1. A Class: 0~127로 시작, 2^24개 호스트
2. B Class: 128~191로 시작, 2^16개 호스트
3. C Class: 192~223로 시작, 2^8개 호스트
4. D Class: 224~239로 시작, 멀티캐스트 용
5. E Class: 실험적 주소, 공용되지 않음

##  서브네팅

- 이미 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것
- 첫 번째 주소 -> 호스트 주소
- 마지막 주소 -> 브로드캐스트 주소

## IPv6

- 128비트의 주소 사용
- 구성
  - 유니 캐스트(1:1 통신)
  - 멀티 캐스트(1:N 통신)
  - 애니 캐스트(1대1 통신)

## 도메인 네임

- 숫자로 된 IP주소를 사람이 이해하기 쉬운 문자 형태로 표현

# 176. OSI 참조 모델

- ISO에서 제안한 통신 규약

## 1. 물리 계층

- 실제 접속 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙
- 물리적 전송 매체아 전송 신호 방식을 정의
- RS-232C, X.21
- **리피터, 허브**

## 2. 데이터 링크 계층

- 시스템 간의 연결 설정과 유지 및 종료 담당
- 흐름 제어, 오류 제어, 순서 제어 기능
- 프레임 동기화 기능
- HDLC, LAPB, LLC, MAC, LAPD, PPP
- **랜카드, 브리지,  스위치**

## 3. 네트워크 계층

- 네트 워크 연결 관리, 데이터 교환 및 중계 기능
- 네트워크 연결 설정, 유지, 해제
- 경로 설정, 트래픽 제어, 패킷 정보 전송
- X.25, IP
- **라우터**

## 4. 전송 계층

- 하위 3계층과 상위 3계층의 인터페이스 담당
- 종단 시스템간의 전송 연결 설정, 데이터 전소으 연결 해제 기능
- 주소 설정, 다중화, 오류 제어, 흐름 제어
- TCP, UDP
- **게이트웨이**

## 5. 세션 계층

- 대화 구성 및 동기 제어, 데이터 교환 관리 기능
- **동기점**: 오류가 있는 데이터의 회복을 위해 사용 / 소동기점, 대동기점

## 6. 표현 계층

- 통신에 적당한 형태로 변환 or 응용 계층에 맞게 변환
- 시스템 간의 상호 접속을 위해 필요
- 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥관리 기능

## 7. 응용 계층

- OSI 환경에 접근할 수 있도록 서비스 제공
- 응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널

# 177. 네트워크 관련 장비

## 네트워크 인터페이스 카드(NIC)

- 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결

## 허브

- 가까운 거리의 컴퓨터를 연결, 각각의 회선을 통합하여 관리
- 리피터 역할 포함

## 리피터

- 수신 신호를 재생시키거나 출력 전압을 높여 전송

## 브리지

- LAN과LAN을 연결하거나 LAN안에서의 컴퓨터 그룹을 연결

## 스위치

- LAN 과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치

## 라우터

- 데이터 전송의 최적 경로를 선택하는 기능이 추가

## 게이트웨이

- 프로토콜 구조가 다른 네트워크를 연결
- 세션, 표현, 응용 계층 간 연결

# 178. TCP/IP

## 프로토콜

- 서로 다른 기기 간 데이터 교환을 원할하게 수행하기 위한 표준화 통신 규약
- 프로토콜 기본 요소
  - 구문(Syntax)
  - 의미(Semantics)
  - 타이밍(Timing)

## TCP/IP

- 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜

### TCP

- OSI 4계층인 전송 계층
- **가상 회선 방식** 기반의 연결형 서비스
- 패킷 다중화, 순서 제어, 오류 제어, 흐름 제어

### IP

- OSI 3계층인 네트워크 층
- **데이터그램 방식** 기반의 비연결형 서비스
- 패킷 분해/조립, 주소 지정, 경로 선택

## 응용 계층 주요 프로토콜

- FTP: 원격 파일 전송 프로토콜
- SMTP: 전자 우편 교환
- TELNET: 원격 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용
- SNMP: 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는데 사용
- DNS: 도메인 네임을 IP주소로 매핑
- HTTP: 월드 와이드 웹에서 HTML문서 송수신

## 전송 계층의 주요 프로토콜

- TCP
  - 양방향 연결형 서비스
  - 가상회선 연결형
  - 스트림 위주의 패킷 단위 전달
- UDP
  - 비연결형 서비스
  - 전송 속도가 빠름
  - 신뢰성보다는 속도가 중요시, 실시간 전송에 유리
- RTCP
  - RTP 패킷의 전송 품질을 제어

## 인터넷 계층 주요 프로토콜

- IP: 전송할 데이터에 주소를 지정 경로를 설정, 비연결형인 데이터그램 방식 사용
- ICMP(인터넷 제어 메시지 프로토콜): 통신 중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지 관리
- IGMP(인터넷 그룹 관리 프로토콜): 호스트나 라우터 사이에서 멀티캐스트 그룹 유지
- ARP(주소 분석 프로토콜): 호스트의 IP주소를 물리적 주소로 바꿈
- RARP: 물리적 주소를 IP주소로 변환

## 네트워크 액세스 계층 주요 프로토콜

- 이더넷: CSMA/CD 방식 LAN
- IEEE 802: LAN을 위한 표준 프로토콜
- HDLC: 비트 위주 데이터 링크 제어 프로토콜
- X.25: 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스 제공
- RS-232C: PSTN을 통한 DTE와 DCE 간의 인터페이스 제공

# 179. 네트워크 관련 신기술

- IoT: 사물인터넷
- M2M: 사물통신
- 모바일 컴퓨팅
- 클라우드 컴퓨팅
- 그리드 컴퓨팅: 컴퓨터를 연결하여 공유
- 모바일 클라우드 컴퓨팅
- 인터클라우드 컴퓨팅: 여러 클라우드 서비스나 자원 연결
- 메시 네트워크: 특수 목적의 새로운 방식 네트워크 기술
- Wi-SUN: 사물인터넷을 위한 저전력 장거리 통신
- NDN(Named Data Networking): 콘텐츠 자체 정보와 라우터 기능만으로 데이터 전송
- NGN(Next Generation Network): 완전한 이동성 제공을 목적으로 개발
- SDN(Software Defined Networking): 여러 사용자가 각각의 소프트웨어로 네트워킹 가상화
- NFC: 고주파를 이용한 근거리 무선 통신
- UWB: 짧은 거리에서 많은 양의 데이터를 낮은 전력으로 전송
- 피코넷: 블루투스나 UWB 통신을 사용하는 무선 통신망
- WBAN: 기기를 무선으로 연결하는 개인 영역 네트워킹 기술
- USN: 각종 센서로 수집한 정보를 무선으로 수집
- SON: 주변 상황에 맞추어 스스로 망을 구성
- Ad-hoc 네트워크: 모바일 호스트만을 이용하여 구성한 네트워크
- 네트워크 슬라이싱: 하나의 물리적 코어 네트워크 인프라를 독립된 다수의 가상 네트워크로 분리
- BLE: 저전력 블루투스 기술
- 지능형 초연결망: 급격하게 증가하는 데이터 트래픽을 효과적으로 수용
- 파장 분할 다중화(WDM): 광섬유를 이용한 파장이 서로 다른 복수 신호 전송
- 소프트웨어 정의 데이터 센터(SDDC): 데이터 센터의 모든 자원을 가상화하여 소프트웨어로 관리
- 개방형 링크드 데이터(LOD): 누구나 사용할 수 있도록 공개된 연계 데이터

# 180. 네트워크 구축

## 네트워크

- 두 대 이상의 컴퓨터를 전화선이나 케이블 등으로 연결하여 자원을 공유

### 성현

- 중앙 집중형
- 포인트 투 포인트
- 단말 추가 제거 쉬움

### 링형

- 단말 추가 제거 및 기밀 보호가 어려움
- 각 단말에서 전송 지연 발생 가능

### 버스형

- 한 개의 통신 회선에 여러 대의 단말이 연결

### 계층형

- 트리형으로 분산 처리 시스템에 적합

### 망형

- 모든 지점의 컴퓨터와 단말을 서로 연결

## 네트워크 분류

- 근거리 통신망(LAN)
- 광대역 통신망(WAN)

## NAT(Network Address Translation, 네트워크 주소 변환)

- 한 개의 정식 IP 주소에 대량의 가상 사설 IP 주소를 할당 및 연결

# 181. 스위치

- L2 스위치

  - OSI 2계층
  - MAC 주소를 기반한 프레임 전송
  - 동일 네트워크 간 연결

- L3 스위치

  - OSI 3계층
  - 라우터 기능 추가, IP 주소 기반 패킷 전송
  - 서로 다른 네트워크 간 연결

- L4 스위치

  - OSI 4계층
  - 로드밸런서 추가, IP 주소 및 TCP/UDP 기반

- L7 스위치

  - OSI 7계층
  - 패킷 내용까지 참조하여 로드밸런싱

  # 182. 경로 제어 / 트래픽 제어

  ## 경로 제어(Routing)

  - 전송 경로 중에 최적 패킷 교환 경로를 결정
  - "경로 제어표"를 참조
  - 라우터에 의해 수행

  ## 경로 제어 프로토콜

  - IGP(내부 게이트웨이 프로토콜): 하나의 자율 시스템 내의 라우팅에 사용
    - RIP: 거리벡터 라우팅 프로토콜 (벨만 포드 알고리즘 사용)
    - OSPF: 최단 경로 탐색에 다익스트라 알고리즘사용
  - EGP(외부 게이트웨이 프로토콜): 자율 시스템(게이트웨이) 간의 라우팅
  - BGP(경계 게이트웨이 프로토콜): 자율 시스템 간의 라우팅 사용, EGP 단점 보완
    - 초기에 BGP 연결 시 ""전체 경로 제어표""를 교환

  ## 트래픽 제어

  - 전송되는 패킷의 흐름 또는 그 양을 조절

  ### 흐름 제어

  - 송수신 측 사이에 전송되는 패킷의 양이나 속도를 규제
  - Stop-and-Wait
  - Sliding Window

  ### 폭주 제어

  - 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로를 방지
  - 느린 시작: 윈도우 크기를 지수적로 증가
  - 혼잡 회피: 지수적 증가가 임계값에 도달하면 윈도우 크기를 1씩 선형적으로 증가

  ### 교착상태 방지

# 183. SW 관련 신기술

- 인공지능
- 뉴럴링크
- 딥러닝
- 전문가 시스템: 전문가의 업무를 지원하는 응용 프로그램
- 증강현실
- 블록체인
- 분산원장기술(DLT): 중앙 데이터 저장소가 없이 P2P 망 내의 참여자 모두에게 거래 목록 분산 저장
- 해시
- 양자 암호키 분배(QKD)
- 프라이버시 강화 기술(PET): 개인정보 침해 위험 관리
- 공통 평가 기준(CC): 정보화 제품의 정보 보호 기능과 사용환경 등급
- 개인정보 영향평가 제도(PIA)
- 그레이웨어: 사용자 입장에서 유용할 수도, 악의적일 수도 있는 소프트웨어
- 매시업: 웹에서 제공하는 정보나 서비스로 새로운 서비스, 데이터를 만드는 기술
- 리치 인터넷 애플리케이션(RIA): 플래시 웹 페이지 제작 기술
- 시맨틱 웹: 이해하기 쉬운 차세대 지능형 웹
- 증발품: 배포 계획은 발표되었으나 배포되지 않고 있는 소프트웨어
- 오픈 그리드 서비스 아키텍처(OGSA)
- 서비스 지향 아키텍처(SOA)
- 서비스형 소프트웨어 (SaaS)
- 소프트웨어 에스크로
- 복잡 이벤트 처리(CEP)
- 디지털 트윈

# 186. HW 관련 신기술

- 고가용성(HA): 장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경
- 3D Printing
- 4D Printing
- RAID: 여러 개의 하드디스크로 디스크배열을 구성하여 여러 디스크에서 동시에 읽기 쓰기 가능
- 4K 해상도
- 앤 스크린: N개의 서로 다른 단말기에서 동일한 콘텐츠를 이용
- 컴패니언 스크린: TV 방송 시청 시 방송 내용 공유 + 추가적인 기능 수행
- 신 클라이언트 PC: 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터
- 패블릿: 5인치 이상 스마트폰
- C형 유에스비
- 멤스(MEMS):  초정밀 반도체 제조 기술 바탕으로한 초미세 장치
- 트러스트존 기술
- 엠디스크: 한 번의 기록으로 자료를 영구 보관 가능한 광 저장장치
- 멤리스터: 메모리 + 레지스터

# 188. DB 관련 신기술

- 빅데이터
- 브로드 데이터: 새로운 데이터나 새로운 가치가 더해진 데이터
- 메타 데이터
- 디지털 아카이빙: 디지털 정보 자원을 장기적으로 보존
- 하둡: 분산 컴퓨팅 플랫폼
- 맵리듀스: 대용량 데이터를 분산 처리하기 이한 프로그래밍 모델
- 타조: 하둡 기반의 분산 데이터 웨어하우스 프로젝트
- 데이터 다이어트: 데이터 압축, 중복 제거, 새로운 기준에 따른 분류 등
- 데이터 마이닝: 대량의 데이터에서 상호 관계를 규명하여 일정한 패턴을 찾는 기법
- OLAP: 다차원 데이터로부터 통계 분석을 통해 의사결정에 활용

# 189. 회복 / 병행제어

## 회복

- 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구

### 연기 갱신 기법

- 트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 실질적인 갱신 연기

### 즉각 갱신 기법

- 트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영

### 그림자 페이지 대체 기법

- 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하고
  각 페이지를 복사본인 그림자 페이지를 별도 보관하고
  장애 발생 시 그림자 페이지를 가져와 회복

### 검사점 기법

- 검사점을 로그에 보관하고 장애 발생 시 검사점부터 회복 작업 수행

## 병행제어

- 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어

### 로킹

- 트랜잭션들이 로킹 단위 액세스 전 Lock을 요청하여 허락되면 액세스 가능

### 타임 스탬프 순서

- 시간표를 부여하여 시간에 따라 트랜잭션 수행

### 최적 병행수행

- 대부분이 판독 전용 트랜잭션일 경우, 그냥 실행되어도 시스템 상태는 일관성 있게 유지

### 다중 버전 기법

- 갱신될 때 마다 버전을 부여하여 관리

### 로킹 단위

- 한꺼번에 로킹할 수 있는 객체의 크기

# 190. 교착상태

- 상호 배제에 의해 발생
- 둘 이상의 프로세스가 서로 다른 프로세스가 가진 자원을 요구하여 무한정 기다리는 현상

## 교착 상태 발생 필요 충분 조건

1. 상호 배제: 한 번에 한 개의 프로세스만이 공유 자원을 사용해야 함
2. 점유와 대기: 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함
3. 비선점: 다른 프로세스의 자원은 사용이 끝나기 전까지 강제로 빼앗을 수 없어야 함
4. 환형 대기: 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구

## 교착상태 해결 방법

- 예방 기법: 발생 조건 네 가지 중 하나를 제거
- 회피 기법: 은행원 알고리즘 사용
- 발견 기법: 시스템에서 교착상태 점검
- 회복 기법: 교착 상태의 프로세스를 종료하거나 자원을 선점하여 회복

# 193. 릴리즈 노트

- 소프트웨어 개발 과정에서 정리된 릴리즈 정보를 최종 사용자인 고객과 공유하기 위한 문서

# 194. 디지털 저작권 관리(DRM)

- 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록
  전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술

## 클리어링 하우스

- 권한 정책 / 라이선스
- 저작권에 대한 사용 권한 / 라이선스 발급 / 암호호된 키 관리 등

## 콘텐츠 제공자

- 패키저(콘텐츠와 메타 데이터를 묶어 암호화하여 배포) / 콘텐츠 / 메타 데이터

## 콘텐츠 분배자

- 유통 시스템

## 콘텐츠 소비자

- DRM 컨트롤러(배포된 콘텐츠의 이용 권한 통제) / 보안 컨테이너(콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치)

## 디지털 저작권 관리 기술 요소

- 암호화
- 키 관리
- 암호화 파일 생성
- 식별 기술
- 저작권 표현
- 정책 관리
- 크랙 방지
- 인증

# 197. 소프트웨어 버전 등록

## 형상 관리

- 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련으 ㅣ활동

## 형상 관리 기능

- 형상 식별
- 버전 제어
- 형상 통제
- 형상 감사
- 형상 기록

## 소프트웨어 버전 등록 관련 주요 기능

- 저장소(Repository)
- 가져오기(Import)
- 체크아웃(Check-Out)
- 체크인(Check-In)
- 커밋(Commit)
- 동기화(Update)

## 소프트웨어 버전 등록 과정

1. 가져오기
2. 인출
3. 예치
4. 동기화
5. 차이



# 198. 소프트웨어 버전 관리 도구

- 공유 폴더 방식: 지역 컴퓨터의 공유 폴더에 저장
- 클라이언트/서버 방식: 서버에 저장되어 관리
- 분산 저장소 방식: 하나의 원격 저장소와 분산된 개발자 PC의 지역 저장소에 함께 저장
- Subversion(서브비전): CVS 개선, 클라이언트/서버 구조
- Git: 분산 버전 관리 시스템
  - add
  - commit
  - branch
  - checkout
  - merge
  - init
  - remote add
  - push
  - fetch
  - clone
  - fork

# 200. 빌드 자동화 도구

- Jenkins: JAVA 기반 오픈 소스 형태
- Gradle: Groovy 기반 오픈 소스 형태  / 안드로이드 개발 환경에서 사용
